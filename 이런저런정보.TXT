클립보드 기록에 액세스하려면 Windows 로고 키 + V를 누릅니다

==============================================================================================================================
<객체 또는 API 종류>
documenet : 웹페이지의 tag 제어시 검색해 볼 객체
DOM (Document Object Model) : documenet 객체에 없을때 확대하여 검색해 볼 객체
window : 웹페이지가 아닌 웹브라우저 제어시 검색해 볼 객체
ajax : 웹페이지를 리로드하지 않고 정보 변경 시 현대적 웹앱 만들때 필수 테크닉
cookie : 웹페이지를 리로드하지 않고 현 상태를 유지하도록 구현시
offile web application : 인터넷 끊겨도 동작하는 웹 구현시
webRTC : 화상통신 웹앱
speech : 음성지원 구현시
webGL : 3차원 그래픽 구현시(게임)
webVR : 가상 현실 구현시
==============================================================================================================================
<JavaScript 참고 사이트>
https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function

https://www.inflearn.com/courses/lecture?courseId=334104&type=LECTURE&unitId=228296&subtitleLanguage=ko
https://www.inflearn.com/courses/lecture?courseId=334104&tab=curriculum&type=LECTURE&unitId=228296&subtitleLanguage=ko&audioLanguage=ko

https://chatgpt.com/
https://developer.mozilla.org/ko/docs/Web/JavaScript
https://joshua1988.github.io/vue-camp/js/variable.html
https://joshua1988.github.io/vue-camp/es6+/const-let.html
https://joshua1988.github.io/web-development/opinions/how-to-use-chatgpt-part1/
https://joshua1988.github.io/web-development/opinions/how-to-use-chatgpt-part2/

<Vue 공식문서>
https://www.inflearn.com/courses/lecture?courseId=324088&type=LECTURE&unitId=21473


------------------------------------------------------------------------------------------------------------------------------------
<CSS예제>
 <style>
    a { 
        color:black;
        text-decoration: none;
    }
    
    #active {
        color:red
    }

    .saw {
        color:gray;
    }

    h1 {
        font-size:45px;
        text-align: center;
    }
</style>

 selector 우선순위 : 구체적인 것이 가장 우선순위가 높다. 즉 actcive실행 -> saw실행 -> a(tag)실행
           #(id) > .(class) > tag <br><br>
        
           검색어 예제 : css text size property, css text align center, css selector 
------------------------------------------------------------------------------------------------------------------------------------

구글검색시 : mdn foreach, mdn array 등등

<Array 예제)
let arr=[10,20,30];

arr.push(40); //추가 arr=[10,20,30,40]
arr.pop(40);  //삭제 arr=[10,20,30]
--------------------------------------------------------------
arr.forEach(
function (value) {
    console.log(value);
}
);

arr.forEach((value) => console.log(value));

arr.forEach(value => console.log(value));

--------------------------------------------------------------

arr.map (function (value) {
    return value *10;
}
);

arr.map(value => value * 10);

=> 이때, arr의 값은 변경되지 않고 변경된 값만 return 받음.
--------------------------------------------------------------

arr.filter(function (value) {
    if(value==10) return true;
})

=> 이때, arr의 값은 변경되지 않고 filter된 값만 return 받음.
--------------------------------------------------------------

<Vue 예제>

props:[] => 부모---> 자식 (props)
this.$emit('') => 자식 ---> 부모 (evnet)

같은 레벨(자식)간의 데이타 전달 => 자식 --> 부모 ---> 자식 (즉 $emit() -> 부모에게 전달 -> props:['']로 다른 자식에서 전달

Vue 템플릿 문법은 데이터 바인딩과 디렉티브로 나뉘어요. 화면에 데이터를 연결하고 DOM을 조작하는 두 가지 주요 방법입니다.

`v-bind` 디렉티브는 Vue 인스턴스의 데이터를 HTML 태그의 속성(attr)에 연결하여 동적으로 관리할 때 사용됩니다. 클래스나 ID 바인딩에 자주 쓰여요.
`v-if`는 조건이 false일 때 DOM에서 요소를 완전히 제거하지만, `v-show`는 `display: none` CSS 스타일로 숨깁니다. 성능 및 사용 사례에 차이가 있어요.
`v-model` 디렉티브는 폼 입력 요소(input, textarea 등)와 Vue 데이터 간에 양방향 바인딩을 쉽게 구현할 수 있도록 해줍니다. 사용자 입력과 데이터를 동기화하죠.
`v-on:submit.prevent
폼 제출 시 브라우저의 기본 동작(페이지 새로고침)을 막기 위해 `v-on:submit` 디렉티브에 함께 사용할 수 있는 이벤트 수식어 
=> `.prevent` 수식어를 사용하면 이벤트의 기본 동작을 막을 수 있습니다. 폼 제출 시 발생하는 페이지 새로고침을 방지하는 데 유용해요.

뷰다이렉트(v-bind, v-if, v-else, v-on 등등) 는 Vue의 data 또는 computed 요소를 참조한다.
v-if, v-else => DOM 요소에서 보이지 않음
v-show => DOM 요소에서 보임

computed  : 연산 또는 validation 체크시, 바로 실행되는 로직에 사용
watch : 무거운 로직, 매번 실행하기에는 무거운 로직들이 필요할때, 데이타 요청시 사용
watch보다는 computed를 사용을 권장한다.
`watch`는 특정 데이터의 변경을 감지하고, 그 변화에 따라 API 호출 같은 부수 효과나 무거운 로직을 실행하는 데 적합해요. 데이터 변화에 대한 '반응'이 핵심입니다.
`watch`는 데이터 변화에 따른 부수 효과(side effects)를 처리할 때 유용해요. 서버 통신이나 복잡한 DOM 조작 등 데이터 변화 외의 동작이 필요할 때 사용합니다.
`computed`는 기존 데이터를 활용하여 새로운 파생 데이터를 만들 때 사용해요. 계산 결과는 캐싱되어 의존 데이터가 변하지 않으면 재계산되지 않아 효율적이죠.
`computed`는 의존하고 있는 데이터가 변경되지 않으면 이전에 계산된 결과를 재사용하는 캐싱 기능이 있어요. 이는 불필요한 재계산을 막아 성능을 향상시키죠.
`computed` 속성은 데이터 상태를 기반으로 계산된 값을 반환하므로, 이 값을 `v-bind:class`에 연결하여 클래스 이름을 동적으로 제어할 때 매우 유용하고 코드를 깔끔하게 만들 수 있어요.
간단한 데이터 계산 결과를 템플릿에 표시할 때, `watch` 대신 `computed` 사용이 권장


<모르는 문법이 나왔을때 공식문서보고 해결하는 방법>
1.https://vuejs.org/ 오픈
2.검색항목에 찾고자 하는 문법 (ex>input) 입력
**화면내 Guide 나 API 메뉴 활용

=============================================================================================================================
node.js 설치 후
node -v  => 노드 버전 확인
npm -v => NPM 버전 확인

npm -v 가 실행되지 않을때 powershell 권한 변경 => set-ExecutionPolicy RemoteSigned
npm install -g @vue/cli  => VUE CLI 설치
sudo npm install -g @vue/cli => VUE CLI 설치가 안될때
vue --version  => VUE 버전 확인

** Vue CLI 공식 사이트 링크 : https://cli.vuejs.org/guide/installation.html

===============================================================================================================================================
Vue CLI (Vue Command Line Interface (Vue 명령줄 인터페이스)) 는 명령어를 통해 Vue 프로젝트를 쉽고 빠르게 구성하고 개발할 수 있도록 지원하는 도구
=> Vue 프로젝트 개발을 돕는 커맨드 라인 도구

<Vue CLI 프로젝트 생성>
[vue CLI 2.x 버전]
vue init '프로젝트 템플릿 유형' '프로젝트 폴더 위치'
vue init webpack-simple '프로젝트 폴더 위치'

[vue CLI 3.x 버전]
vue create '프로젝트 폴더 위치'
vue create vue_cli

cd vue-cli
npm run serve => 서버 실행

`npm run serve`
=> `package.json` 파일의 `scripts` 속성에 `serve` 같은 명령어가 정의되어 있어요. npm run으로 이를 실행합니다.

Local => http://localhost:8080/  로 화면 확인

파싱 오류시 : .eslintrc.js 파일 생성

Vue 컴포넌트 템플릿은 안정적인 구조와 정상적인 렌더링을 위해 반드시 하나의 최상위 HTML 요소로 감싸져야 해요. 여러 개가 있으면 오류가 발생할 수 있답니다.

컴포넌트 파일 이름은 대문자로 시작하는 파스칼 케이스(ex> AppHeader)를 사용해서 HTML 기본 태그와 혼동되지 않도록 구분하는 것이 권장됩니다. 최소 두 단어 이상 사용도 중요해요.
Vue CLI 프로젝트에서 애플리케이션이 시작되는 주요 진입점 파일은 => main.js
`main.js` 파일에서 Vue 앱 인스턴스를 생성하고, 필요한 설정을 로드한 후, `index.html`의 특정 요소에 앱을 마운트하여 화면에 표시합니다.

Vue 컴포넌트 data를 함수 형태로 정의하고 객체를 반환하는 주된 이유는 무엇일까요? => 컴포넌트 인스턴스 간 데이터 공유 방지
`data` 속성을 함수로 만들면 각 컴포넌트 인스턴스가 독립적인 데이터 객체를 가집니다. 이를 통해 인스턴스 간 데이터 공유를 방지할 수 있어요.
===============================================================================================================================================
npm i axios => axios 특정 라이브러리를 사용할 수 있게 다운받는 것

<script>
import axios from 'axios'; 
</script>
===============================================================================================================================================

Axios 
node.js와 브라우저를 위한 Promise 기반 HTTP 클라이언트 라이브러리이다.
Axios는 백엔드와 통신하기 위해 AJAX 요청을 만들고 응답을 다루는 데에 사용된다.

`Axios`는 HTTP 클라이언트 라이브러리로, 브라우저와 Node.js에서 서버와 데이터 통신(AJAX 요청 등)을 쉽게 처리할 수 있게 돕습니다.

React(라이브러리)와 Vue.js에서 데이터를 fetch하는 기본 라이브러리이며 현대 웹 환경에서 서버에서 데이터를 받아오는 일은 
이 라이브러리를 기반으로 이루어지고 있다.

서버 사이드에서는 네이티브 node.js의 http 모듈을 사용하고, 클라이언트(브라우저)에서는 XMLHttpRequests를 사용합니다.

<특징>
브라우저를 위해 XMLHttpRequests 생성
node.js를 위해 http 요청 생성
Promise API를 지원
요청 및 응답 인터셉트
요청 및 응답 데이터 변환
요청 취소
JSON 데이터 자동 변환
XSRF를 막기위한 클라이언트 사이드 지원

axios github 활용
오픈소스 라이브러리 참고시 => start 수, commit 수, 참여자 수, commit 일자 참고



==============================================================================================================================

Legacy 시스템은 낡은 기술이나 방법론, 컴퓨터 시스템, 소프트웨어 등을 말한다. 
이는 현대까지도 남아 쓰이는 기술을 부르는 말일 수 있지만 더이상 쓰지않더라도 현대의 기술에 영향을 주는 경우도 포함한다. 
따라서 공생해야하거나 기반이 되는 오래된 시스템을 주로 레거시 시스템이라고 한다.

.
==============================================================================================================================

REST(Representational State Transfer)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미합니다.

즉 REST란 
HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,
HTTP Method(POST, GET, PUT, DELETE)를 통해
해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미합니다.
 

CRUD Operation이란
CRUD는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말로 
REST에서의 CRUD Operation 동작 예시는 다음과 같다.
 

Create : 데이터 생성(POST)
Read : 데이터 조회(GET)
Update : 데이터 수정(PUT)
Delete : 데이터 삭제(DELETE)

REST 구성 요소
REST는 다음과 같은 3가지로 구성이 되어있다. 


자원(Resource) : HTTP URI
자원에 대한 행위(Verb) : HTTP Method
자원에 대한 행위의 내용 (Representations) : HTTP Message Pay Load


REST의 특징
Server-Client(서버-클라이언트 구조)

Stateless(무상태)

Cacheable(캐시 처리 가능)

Layered System(계층화)

Uniform Interface(인터페이스 일관성)

REST의 장단점
장점 

HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.

HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해 준다.

HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.

Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.

REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.

여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다.

서버와 클라이언트의 역할을 명확하게 분리한다.

 

단점 

표준이 자체가 존재하지 않아 정의가 필요하다.

사용할 수 있는 메소드가 4가지밖에 없다.

HTTP Method 형태가 제한적이다.

브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 정보의 값을 처리해야 하므로 전문성이 요구된다.

구형 브라우저에서 호환이 되지 않아 지원해주지 못하는 동작이 많다.(익스폴로어)

REST Client = Http Client

============================================================================================================================================================================================

SPA(Single Page Application) 

프론트엔드 / 백엔드

프론트엔드 개발자는 백엔드 API에서 가져온 데이터의 출력, 입력을 통한 비즈니스 로직 구성과 사용자와 대화하는 사용자 인터페이스 부분을 작업하는 개발자를 말한다.

분별하기 헷갈리는 직종으로 웹 퍼블리셔가 있는데, 웹 퍼블리셔(해외에서는 UI 개발자로 불린다)는 HTML 중심이거나, 
서버 사이드가 감싸는 구조 형태의 웹을 지향하는 웹 퍼블리셔와 개발자의 업무 스타일의 직군으로서 웹표준 반응형 웹과 UI를 만드는 디자인 쪽에 가깝기에 데이터 처리, 비즈니스 로직을 개발하진 않는다. 
요즘은 마크업 개발자라고 불린다. 클라이언트 사이드 영역이기도 하지만, 프론트엔드 개발자는 프론트엔드, 백엔드의 완전한 분리 구조를 지향하는 업무 스타일의 직군으로서 웹 퍼블리셔와 같이 
인터페이스의 디자인 관점도 있지만, 웹 퍼블리셔와 달리 DOM 조작이 아닌 컴포넌트 아키텍처와 데이터 상태의 변화로 처리하며, 이벤트나 서버와 API 통신해서 비즈니스 로직을 푸는 관점을 가장 중시한다.

프론트엔드 개발자는 프론트 영역 전반과 서버에 대한 이해력을 필요로 한다. 
프론트엔드 개발자가 담당하기도 하지만, 종종 업무 효율을 위해 디자인 영역(HTML, CSS)만 작업해주는 마크업 개발자가 따로 있는 경우도 있으며, 프론트엔드 개발자는 해당 작업 파일을 받아 포팅 작업을 하고, 
프론트엔드 영역을 개발하게 된다. 즉 프론트엔드 개발자는 바닐라 JS와 HTTP 프로토콜, 웹팩 등이 중요하다고 볼 수 있다.

백엔드 개발자도 기존 개발자와 스펙이 조금 다르고, 백엔드의 뷰는 화면 개발이 아닌 API 개발이고, 백엔드 인증 처리도 따로 알아야 하며, 데이터베이스 분석과 API서버를 개발한다. 
웹 퍼블리셔와 개발자로 나뉜 방식은 모든 호출을 서버에서 가져와야 했고, 컴포넌트화가 안 되었지만, 프론트엔드와 백엔드로 나뉜 개발 방식은 서버의 컴퓨터와 사용자 컴퓨터가 http통신으로 데이터만 교환하고 
완전히 분리 구조를 지향한다. 점점 데이터의 복잡성이 커지고, SPA(Single Page Application) 및 재사용성이 중요함에 따라 각광받는 직종이다. 이런 거 만들어주는 사이트들도 존재한다.

==============================================================================================================================

JavaScript

Ecma International의 프로토타입 기반의 프로그래밍 언어로, 스크립트 언어에 해당된다. 
특수한 목적이 아닌 이상 모든 웹 브라우저에 인터프리터가 내장되어 있다. => JavaScript는 기본적으로 인터프리터 언어
오늘날 HTML, CSS와 함께 웹을 구성하는 요소 중 하나다. HTML이 웹 페이지의 기본 구조를 담당하고, CSS가 디자인을 담당한다면 JavaScript는 클라이언트 단에서 웹 페이지가 동작하는 것을 담당한다.[1] 
웹 페이지를 자동차에 비유하자면, HTML은 자동차의 뼈대, CSS는 자동차의 외관, JavaScript는 자동차의 동력원인 엔진이라고 볼 수 있다.

썬 마이크로시스템즈(현재 오라클)에서 개발한 Java와는 별 관계가 없는 언어이다. 이름이 비슷하다고 같은 언어가 아니다. 
사람들이 흔히 헷갈리는 부분 중 하나라 Java의 소유자인 오라클에서도 아니라고 강조한다.[2] 
실질적인 구동 방식도 Java Virtual Machine을 이용해서 돌리는 Java와, 브라우저 내에 스크립트 엔진(인터프리터)이 존재하는 JavaScript는 완전히 다르다. 
햄이랑 햄스터가 다르고 파와 파슬리가 다르며, 인도가 인도네시아와 다르듯[3] 심지어는 웹 서버용 파생 규격도 서로 다르다.

날코딩 항목에서 서술되어 있듯, 웹 개발자들은 다양한 마크업 언어 및 프로그래밍 언어를 사용하기 때문에 통합 개발 환경보다는 텍스트 에디터를 사용하는 경우가 많다. 
크롬이나 파이어폭스에서는 개발자 도구를 지원하여 브라우저에서 개발을 돕기도 한다.
# 텍스트 에디터로는 그냥 메모장을 사용하는 사람들도 있지만 EditPlus, UltraEdit, Notepad++, vim이 주로 사용되었다. 
통합 개발 환경이 필요하다면 JetBrains의 WebStorm이 권장되는데 이는 유료이다.[12] 
이클립스의 JavaScript Development Tools는 무료. 하나 이클립스의 무거움은 그대로 가지고 있다.

최근에는 GitHub의 Atom[13], Microsoft의 Visual Studio Code, Adobe의 Brackets[14] 등의 오픈 소스 에디터도 출시되고 있다.[15] 
해외의 경우 99프로 가까이 비주얼 스튜디오 코드를 쓰는 만큼 웹 개발에 비주얼 스튜디오 코드는 사실상 업계 표준이다. 

표준화를 거친 JavaScript는 AJAX, jQuery 등의 등장으로 거침없는 발전을 보였고, 기어이 Node.js의 등장으로 서버 사이드 언어로서 탈바꿈하게 된다. 
JIT 컴파일 방식을 도입한 구글의 V8이라는 JavaScript 엔진을 개발하였고, ECMAScript 6 구현율이 당시 80% ~ 현재 99%에 달하면서 CommonJS, AMD(Asynchronous module definition) 진영 등의 등장도 나타났다. 
과거의 JavaScript와 비교해 보면 격세지감마저 들 정도로 그야말로 장족의 발전이다.
하지만 그렇다고 해서 JavaScript가 마냥 쉬운 언어라고 생각하면 오산이다. 웹으로 할 수 있는게 제한적이었던 과거에는 웹 애플리케이션으로 복잡한 기능을 수행하는게 불가능했기 때문에 
당시 JavaScript로 작성된 코드들은 간단했고, 그로 인해 JavaScript는 쉬운 언어라는 인식이 널리 퍼졌다. 
그러나 현재는 웹 애플리케이션이 사실상 데스크톱 설치형 애플리케이션을 상당수 대체하고 있어 JavaScript 기반으로 쓰여진 초대형 프로젝트들이 많은 상황이고, 
무엇보다 Node.js의 등장으로 인해 프론트엔드뿐만 아니라 백엔드 및 네이티브 프로그래밍에서도 JavaScript가 쓰이는 만큼 지금의 JavaScript는 여타 언어 못지않은 높은 수준의 숙련도를 요구하고 있다고 봐야 한다.

2010년대 중반 이후 JavaScript는 구글의 V8 JavaScript engine 버프를 받아 하루가 다르게 발전하고 있으며 이러한 모양새는 다음 글에서도 잘 나타난다. 
2016년에 JavaScript를 배우는 기분 개발자들 사이에서 이런 발전상이 화제가 되기도 했다. 
과거에는 브라우저 환경에서만 사용이 가능한 웹 전용 프론트엔드 프로그래밍 언어에 불과했지만, 
현재는 Node.js라는 강력한 runtime environment[28]의 등장으로 백엔드 언어로서도 매우 강력한 성능을 가진 언어로 재탄생했으며 실제로도 백엔드 분야에서 빠르게 점유율을 높여가고 있다. 
Node.js 서버는 확장성이 높고 개발자 입장에서도 JavaScript만 알면 접근이 가능해 유지 보수 측면에서도 유리한 면이 있고 무엇보다 I/O가 자주 이루어지는 애플리케이션의 경우 성능이 매우 좋다. 
여기에 ORM 까지 등장하면서 심지어 데이터베이스 시스템이 제공하는 stored procedure까지도 대체가 가능한 수준까지 이르렀다. 
이와 동시에 백엔드 및 프론트엔드 양방향에서 정말 수많은 라이브러리가 등장하면서 발전이 가속화되는 중이다. 
'여기에 HTML5, 반응형 웹 등 다양한 웹 기술의 발달로 인해 사실상 데스크톱 애플리케이션이 쇠퇴하고 웹이 모던 애플리케이션의 표준이 되면서 중요성이 더욱 두드러지는 언어가 되었다. 
실제로 많은 소프트웨어 회사들이 기존 C++나 Java 등으로 쓰여진 PC용 애플리케이션을 웹 앱으로 전환하고 있어[29] 수요도 많고 전망 또한 밝은 언어라 할 수 있다.

ORM(Object Relational Mapping) 개념
ORM(Object Relational Mapping)’은 ‘객체로 연결을 해준다’는 의미로, 어플리케이션과 데이터베이스 연결 시 SQL언어가 아닌 어플리케이션 개발언어로 데이터베이스를 접근할 수 있게 해주는 툴입니다.
ORM은 SQL문법 대신 어플리케이션의 개발언어를 그대로 사용할 수 있게 함으로써, 개발 언어의 일관성과 가독성을 높여준다는 장점을 갖고 있습니다.

이 때문에 현재 JavaScript는 확장성이 매우 높은 언어이다. 
JavaScript만 알면 일반적인 사이트 개발부터 React.js 또는 Vue.js를 사용해 SPA 웹사이트 개발, 
iOS와 안드로이드 앱을 만들수 있는 React Native, 
웹 서버나 다른 서버 사이드 애플리케이션에 Node.js, 
데스크톱 앱은 리눅스, macOS, 윈도우, tvOS 등 플랫폼에서 사용 가능한 Electron을 이용하거나 React Native for Windows를 사용해 Windows 10 SDK까지 접근할 수 있다.[30]
이외에도 순수 JS만을 이용하는 Vanilla JS도 존재한다. 다만 이 경우 빠른 속도를 자랑하지만 역설적으로 프레임워크 미사용에 따라 코드가 더 길어진다는 단점이 존재한다.

원래 JavaScript 엔진들은 모두 실시간 인터프리팅을 하고 있었는데, 모질라에서 SpiderMonkey 엔진에 JIT 컴파일 방식을 도입했다. 이는 JavaScript 엔진으로는 최초로 도입한 것이고, 
이 때 알려진 것으로는 순수 JavaScript 성능만 기존 버전의 20~40배에 달했다.[10] 
그리고 구글 역시 V8이라는 JavaScript 엔진을 개발하면서 JIT 컴파일 방식을 도입하였고, JavaScript 성능이 비약적으로 향상하여 지금은 JavaScript 3D 게임 엔진도 개발되고 있다.[11]


- 주요 라이브러리[편집]
jQuery: DOM Manipulating 라이브러리. 사실상 JavaScript 개발에 필수였던 라이브러리였으나 리액트, 앵귤러 등의 프레임워크의 생산성이 워낙 높다 보니 
        2010년대 후반부터는 사실상 레거시가 되었으며 아주 간단한 웹사이트에서만 쓰이고 안 쓰는 추세다. 기본적으로 document.querySelectorAll('oooo')를 $('oooo')로 쓸 수 있는 등의 기능이 있다.
        
AngularJS: 구글에서 제작한 프론트엔드용 클라이언트 사이드 JavaScript 프레임워크. Angular 1으로도 불린다. 
           백엔드, 프론트엔드를 동시에 작업할 수 있다. MongoDB, Express, AngularJS, Node.js를 함께 사용하여 MEAN Stack으로 많이 사용한다. 
           Angular 2 이후로는 이건 TypeScript를 이용한다. 기본적으로 많은 기능들이 내재되어 있다.
           
React: Facebook에서 만든 프론트엔드용 오픈 소스 라이브러리다.[37] 
       단방향 데이터 흐름과, Virtual DOM 개념을 도입한 UI 컴포넌트 라이브러리. 
       생산성이 높고, DOM 업데이트에 있어서 성능이 매우 빨라 동적인 웹 애플리케이션 구성에 유리하다. 
       그리고 이러한 동적 웹이 모던 웹 애플리케이션의 필수 요소가 되어버린 만큼 출시 이후 꾸준히 점유율을 늘려가며 업계 표준 라이브러리 중 하나로 자리잡았다. 
       최근에는 React Hooks이라 불리는 메소드가 지원되면서 생산성이 더 좋아졌다. 
       html로 뷰를 작성해야 하는 Angular와는 다르게 JSX라는 문법을 지원하면서 JavaScript만으로 애플리케이션을 작성하는 게 가능하다.
       
Vue.js: 중국계 미국인 에반 유가 만든 사용자 인터페이스를 만들기 위한 프론트엔드용 프레임워크이다. 
        굉장히 자유롭고 유연하게 추가 기능들을 불러올 수 있다는 특징이 있으나 추가 기능들을 무분별하게 사용하는 경우 안정성을 떨어뜨릴 수 있다.
        
Node.js: 브라우저 안에서만 작동하던 JavaScript를 브라우저 외의 환경에서 작동할 수 있게 만들어 준 런타임 환경이다.

Express.js: Node.js 환경을 기반으로 만들어진 웹 애플리케이션 프레임워크. 주로 JavaScript로 백엔드를 개발할 때 사용된다.

Deno: Node.js의 개발자 Ryan Dahl이 Node.js의 아쉬운 점을 개선한 JavaScript 런타임 환경이다.

Svelte: Rich Harris가 2016년도 출시한 오픈 소스 프론트엔드 웹 프레임워크이다.

- 기타 라이브러리[편집]
Electron: GitHub에서 만든 HTML+CSS+Javascript 데스크톱 앱 프레임워크.[38]
언더스코어: 리스트 해석, 고차 함수 집합 라이브러리. 홈페이지
Lo-Dash: 위의 언더스코어 라이브러리의 성능 개선 버전.
npm : Node Package Manager
HTML5shiv: Internet Explorer 6~8에서 HTML5가 동작하게 해 주는 JavaScript 파일이다.
Prefix Free: JavaScript 언어로 된 CSS 라이브러리이다. Vendor Prefix 작업을 자동으로 진행하여 준다.

- 사용빈도
React : Vue.js : Angular : 기타 == 5 : 3 : 1 : 1  

- V8, SpiderMonkey 등의 엔진에서 JIT(Just-In-Time) 컴파일을 도입

ES6+는 무엇인가요?
ES6+란 무엇인가? ES6+는 JavaScript의 마지막 버전으로, 새로운 문법과 기능을 제공합니다. 이를 통해 개발자는 코드를 더 빠르고 쉽게 작성할 수 있습니다.

--------------------------------------------------------------------------------------------------------------------------------
NPM(노드 패키지 매니저/Node Package Manager)은 자바스크립트 프로그래밍 언어를 위한 패키지 관리자이다. 
자바스크립트 런타임 환경 Node.js의 기본 패키지 관리자이다.
NPM 은 Node.js를 설치하면 자동으로 설치가 된다. NPM은 명령어로 자바스크립트 라이브러리를 설치하고 관리할 수 있는 패키지 매니저로, 
전 세계 자바스크립트 개발자들이 모두 자바스크립트 라이브러리를 공개된 저장소에 올려놓고 npm 명령어로 편하게 다운로드 가능하다.
다운로드 : https://nodejs.org/ko/
Node.js 설치시 NPM도 함께 설치가 되며, 터미널 실행 후 아래 명령어를 통해 버전 체크하여 설치가 정상으로 되었는지 확인 가능하다.

$ node -v
v12.16.1

$ npm -v
6.13.4
==============================================================================================================================
JIT(just-in-time 컴파일)

컴퓨터 과학과 프로그래밍 언어에서 사용하는 용어. 
C나 C++에서 하는 것처럼 프로그램을 실행하기 전에 처음 한 번 컴파일[1]하는 대신, 프로그램을 실행하는 시점에서 필요한 부분을 즉석으로 컴파일하는 방식을 말한다.

보통 인터프리터 방식의 언어 구현들이 성능 향상을 목적으로 도입하는 경우가 많은데, JIT 컴파일러는 같은 코드를 매번 해석하는 대신 처음 실행될 때 인터프리트를 하면서 
자주 쓰이는 코드를 캐싱한 뒤[2], 이후에는 캐싱된 코드를 가져다 쓰기 때문에 인터프리터의 느린 실행 속도를 개선할 수 있다. 바이트코드 컴파일을 사용하는 Java도 바이트코드를 기계어로 
번역할 때 JIT 컴파일러를 사용한다.

단점이라면 초기 구동 시에는 소스 코드(혹은 바이트코드)를 실행 단계에서 컴파일하는 데에 시간과 메모리를 소모하기 때문에 정적 컴파일된 프로그램에 비해 실행 속도 면에서 손해를 본다는 것으로, 
특히 실행 시간이 매우 짧은 경우에는 애써 컴파일된 코드를 제대로 울궈먹기도 전에 프로그램이 끝나는 배보다 배꼽이 더 큰 상황이 벌어지기도 한다.[3]

크게 나눠서 HotSpot VM과 같이 메소드(함수) 단위로 JIT 컴파일을 하는 방식과, 그보다 더 작은 단위에서 프로그램 실행 흐름을 실시간으로 추적하며 컴파일할 코드를 탐색하는 Tracing JIT 방식으로 분류할 수 있다. 
특히 Tracing JIT의 경우에는 실행 시점에만 알 수 있는 정보를 컴파일에 적극적으로 반영[4]하기 때문에 이론적으로는 정적 컴파일 방식보다 컴파일 속도가 더 빨라질 수도 있다.

미리 컴파일된 코드를 실행하는 것이 아닌, 런타임에 동적으로 코드를 생성하여 실행한다는 특징 때문에 JIT 컴파일러는 잠재적으로 상당한 보안 문제를 가지고 있다. 
특히 JIT 컴파일러 자체에 버그가 있는 경우 곧바로 보안취약점이 되는 경우가 많다. 대표적으로 인텔 CPU 게이트로 유명한 스펙터 보안취약점은 JIT에 의존하는 JavaScript 엔진을 가진 브라우저에서만 발생했다. 
오라클의 HotSpot VM 또한 JIT 컴파일러 버그로 인한 다수의 보안취약점이 있었다.

==============================================================================================================================

jQuery

HTML 속 클라이언트 사이드 스크립트 언어를 단순화하도록 설계된 브라우저 호환성이 있는 JavaScript 라이브러리이다
여전히 웹 프론트엔드에서 막강한 영향력을 차지하고 있는 jQuery이지만 최근 웹 개발의 트렌드는 React, Vue.js, Svelte 같은 SPA용 프레임워크나 라이브러리로 옮겨가고 있다. 
프레임워크를 통해 컴포넌트, MVC, 양방향 데이터 바인딩 등의 고수준적인 개념을 활용하는 것에 반해 jQuery는 여전히 밑바닥 DOM을 건드리는 데 지나지 않는지라...[13]
하지만 프레임워크를 쓰면서도 jQuery의 기능을 사용할 수 있고, 프레임워크가 모든 경우에 정답은 아니기 때문에 jQuery에 대한 수요는 앞으로도 있을 것이다.

jQuery는 다음과 같은 기능을 갖고 있다.
- DOM 엘리먼트 선택
- DOM 트래버설 및 수정(CSS 1-3 지원. 기본적인 XPath를 플러그인 형태로 지원)
- 이벤트
- CSS 조작[1]
- 특수효과 및 애니메이션[2]
- AJAX 및 JSON, XML 파싱
- JavaScript 플러그인을 통한 확장성
- 유틸리티 - 브라우저 종류와 버전,[3][4] "each" 함수[5]

기능적으로야 더 좋은 라이브러리들도 많지만, jQuery가 순식간에 업계를 장악한 특장점은 바로 무지하게 쉽고 간편하다는 점이다. 
'write less, do more.'가 모토로서 비프로그래머인 웹디자이너들도 어렵지 않게 이해할 수 있을 만큼 쉬운 편이다. DOM 구조와 CSS에 대한 지식만 있다면 애니메이션 같은 건 바로 이해가 가능할 정도다. 
실제로 저자인 존 레식은 프로그래머들의 칭찬보다 순수 웹디자이너들의 감사 인사가 더 특별한 기쁨이라고 한다.

출시되었을 당시 좀 더 근본적인 목표는 모든 웹 브라우저에서 동일한 방법으로 자바스크립트를 구현하는 것이었다. 
이것은 동시기에 나온 다른 자바스크립트 라이브러리도 마찬가지였다. jQuery가 나왔던 2000년대 중반은 웹 브라우저들간의 자바스크립트 호환성이 낮아서 개발자들이 골치를 썩던 시절이었다[6]. 
따라서 라이브러리에서 제공하는 별도의 API를 통해 자바스크립트 코드를 작성하고, 라이브러리에서 이 코드를 사용자들이 접속한 웹 브라우저에 맞게 변환하여 실행하는 여러 라이브러리가 나왔고, 
그 중 가장 쉽고 간편한 API 문법을 제공했던 jQuery가 살아남은 것이다.

jQuery는 Behavioral model(행동 모델)에 기초한 아키텍처를 따른다. 특히 jQuery는 메서드 체이닝을 통해 DOM 엘리먼트를 조작한다. 예를 들어 기존에 이렇게 했다면

예제>
const textNode = document.querySelector("#textNode");
textNode.style.color = "red";
document.querySelector("#someDiv").appendChild(textNode);

jQuery를 사용하면 ===> 
jQuery에선 이렇게 한다. 대신에 속도가 좀 더 느리다. 속도가 느린 이유는 jQuery 라이브러리를 거치면서 브라우저에 맞는 네이티브 자바스크립트로 변환된 뒤 실행되기 때문이다.

$("#textNode").css("color","red").appendTo("#someDiv");

* $("#textNode")
  $라는 함수에 인자로 "#textNode"를 넘겨주겠다는 JavaScript 구문이다. jQuery는 기본적으로 $를 함수 이름으로 사용한다. $() 함수에 인자로 DOM selector를 넣어주면 해당하는 DOM 요소를 찾아 리턴해준다.
   (정확히는 DOM요소를 0번째로 가진 특정한 배열을 반환하는데, id는 특정한 상황이 아니라면 무리 없이 쓸 수 있지만 여러 개의 class를 한 번에 셀렉팅 할 경우 javascript의 document.getElementsByClassName()를 
   생각 없이 쓸 때와 같은 상황이 발생한다.)
* $("...").css("color","red") / $("...").css({"color":"red"})
  jQuery의 메소드들은 기본적으로 리턴하는 데이터의 자료형이 jQuery이고, 메소드를 사용할 때는 자료형이 jQuery인 값에 붙여서 호출하도록 설계되어 있다. 
  즉, $("...")를 호출하여 찾고자 하는 DOM 요소를(여기서는 id가 textNode인 요소) jQuery형으로 리턴받고 .css() 메소드를 호출하여 작업을 수행하는 것. 
  메소드 이름을 보면 알겠지만 .css("color","red") 메소드는 대상의 css를 변경한다. 그리고 변경한 DOM 요소를 jQuery형으로 리턴한다. 후자의 경우는 JSON 문법으로 여러 속성을 한꺼번에 지정할 때 사용한다.
* $("...").css("...","...").appendTo("#someDiv") / $("...").css({"...":"..."...}).appendTo("#someDiv")
  앞서 .css() 메소드로 색을 바꾸고 리턴한 요소에 .appendTo() 메소드를 적용하는 구문이다. 이게 가능한 이유는 플루언트(Fluent) 인터페이스 때문이다. 
  메서드의 반환값이 자기 자신의 참조가 되어 무한히 메서드를 이어붙일 수 있는 게 특징.
  

==============================================================================================================================

Vue.js

자바스크립트로 개발된 컴포넌트 구조 기반 프론트엔드 프레임워크. 보통 뷰라고 부른다.
Vue js는 대표적인 프론트엔드 개발 프레임워크로 Angular, React와 함께 프론트엔드 개발도구 3대장으로 뽑히는데요. 
실시간 대시보드, 소셜 미디어 애플리케이션, 전자상거래 플랫폼 개발 등 다양한 플랫폼 개발에 사용되며, 프론트엔드 개발자들 사이에서 매우 인기 있는 프레임워크입니다.
Vue js의 가벼운 크기와 직관적인 문법으로 인해, SPA 개발에 매우 적합한 프레임워크입니다. 
여기서 SPA는 Single Page Application(단일 페이지 애플리케이션)을 의미하는데, 페이지 전환 없이 동적으로 콘텐츠를 로드하고 업데이트하는 웹 애플리케이션을 뜻합니다.

기존의 다중 페이지 애플리케이션은 사용자가 링크를 클릭할 때마다 서버로부터 새로운 페이지를 로드하는 방식이었습니다. 
하지만 SPA는 초기에 전체 페이지를 로드하고, 사용자 인터랙션에 따라 필요한 데이터만 서버로부터 비동기적으로 로드하여 업데이트합니다. 
이를 통해 사용자 경험을 향상시키고 애플리케이션의 성능을 개선할 수 있습니다.


React(라이브러리)
메타에서 개발한 오픈 소스 자바스크립트 라이브러리.
프론트엔드 개발자 사이에서 AngularJS, Vue.js와 더불어 많은 인기를 얻고 있다. GitHub Star 수와 npm 패키지 다운로드 수는 React가 가장 많다.

---------------------------------------------------------------------------------------------------------------------------------------------------------
DOM(Document Object Model / 문서 객체 모델)

오늘날 JavaScript가 가장 널리 쓰이는 분야는 클라이언트용 인터페이스이다. 
이 때 주로 JavaScript는 웹 브라우저에서 제공되는 DOM API를 사용하게 된다.
DOM (Document Object Model)은 웹 문서의 구조화된 표현이다. 이것은 프로그래밍 언어가 웹 페이지 내의 객체에 접근하고 조작할 수 있게 하는 인터페이스로 동작한다. 
주로 자바스크립트에서 웹 페이지의 요소를 선택, 수정, 추가 또는 제거할 때 사용된다.

주요 DOM관련 메서드 및 속성
요소 선택
document.getElementById(id): 주어진 ID를 가진 요소를 반환한다.
document.getElementsByTagName(name): 주어진 태그 이름을 가진 요소들의 목록을 반환한다.
document.getElementsByClassName(name): 주어진 클래스 이름을 가진 요소들의 목록을 반환한다.
document.querySelector(selector): 주어진 CSS 선택자와 일치하는 첫 번째 요소를 반환한다.
document.querySelectorAll(selector): 주어진 CSS 선택자와 일치하는 모든 요소의 목록을 반환한다.
요소 조작
element.textContent 또는 element.innerText: 요소의 텍스트 내용을 가져오거나 설정한다.
element.innerHTML: 요소의 내부 HTML을 가져오거나 설정한다.
element.setAttribute(name, value): 요소의 속성 값을 설정한다.
element.getAttribute(name): 요소의 속성 값을 가져온다.
element.appendChild(childElement): 요소에 자식 요소를 추가한다.
element.removeChild(childElement): 요소에서 자식 요소를 제거한다.
이벤트 리스너
element.addEventListener(event, function): 요소에 이벤트 리스너를 추가한다.
element.removeEventListener(event, function): 요소에서 이벤트 리스너를 제거한다.

// 요소 선택하기
let heading = document.getElementById('myHeading');

// 텍스트 변경하기
heading.textContent = 'New Heading Text';

// 클릭 이벤트 추가하기
heading.addEventListener('click', function() {
    alert('Heading clicked!');
});

---------------------------------------------------------------------------------------------------------------------------------------------------------
JSX (JavaScript XML)은 자바스크립트를 확장한 문법으로, 자바스크립트 코드에서 HTML과 유사한 문법을 사용하여 UI를 정의할 수 있도록 해줍니다. 
리액트에서 HTML과 자바스크립트를 함께 사용하여 컴포넌트를 만들 때 주로 사용됩니다. 
JSX의 특징:
HTML과 유사한 문법:
JSX는 HTML 태그를 사용하여 UI를 정의하며, HTML의 특성들을 그대로 활용할 수 있습니다. 
자바스크립트 표현식 삽입:
JSX 내에서 `{}`를 사용하여 자바스크립트 표현식을 삽입할 수 있으며, 이는 변수, 함수 호출, 연산 등을 가능하게 합니다. 
React 엘리먼트 생성:
JSX 코드는 React의 React.createElement() 함수와 유사한 동작으로 React 엘리먼트를 생성합니다. 
컴파일 필요:
JSX 코드는 브라우저가 이해하는 자바스크립트 코드로 컴파일되어야 합니다. Babel과 같은 컴파일러를 사용하여 JSX를 자바스크립트로 변환할 수 있습니다. 

JSX 사용 예시:

<코드>
<div className="container">
  <h1 className="title">안녕하세요, JSX!</h1>
  <p>이것은 JSX를 사용하여 만든 컴포넌트입니다.</p>
  {/* 자바스크립트 표현식 삽입 예시 */}
  <p>{2 + 2}</p>
</div>

JSX의 장점:
가독성 향상: JSX는 HTML과 자바스크립트를 함께 사용하여 UI를 정의하므로, 코드의 가독성이 높아집니다. 
개발 효율성: JSX는 UI를 정의하는 데 필요한 코드를 줄여주므로, 개발 효율성을 높여줍니다. 
React UI 구성: JSX는 React UI를 구성하는 핵심적인 요소입니다. 
JSX 관련 용어:
React 엘리먼트: JSX 코드로 생성되는 UI의 기본 단위입니다. 
props: 컴포넌트에게 전달되는 데이터입니다. 
children: 컴포넌트 내부에 포함되는 다른 컴포넌트나 텍스트입니다. 

------------------------------------------------------------------------------------------------------------------------------------------------------
리눅스 명령 프롬포트 명령어

ls : 파일이나 디펙토리 목록을 나열하기 위해서 사용하는 리눅스 커맨드
ls -l은 상세 표시
ls -t는 변경 시간이 오래된 순으로 정렬 / ?파일 리스트가 날짜순으로 정렬 / 가장 아랫부분에 최근 파일 출력
tail -1 마지막 한 개 파일만 표시 / 여러개 파일을 확인하고 싶은 경우에는 -1 숫자 부분에 표시하고 싶은 개수 지정
ls -ltr | tail -n +2 | head -1
이런식으로 변경이 가장 오래된 파일을 찾을 수 있다.
ls -ltr 또한 오래된 순부터 최신순으로 정렬 출력
tail -n +2 결과의 2행부터 마지막까지 출력
tail -n +2를 사용하면 total이라는 폴더 안의 사용량을 출력해주는 부분을 생략할 수 있다.
ls -lt | tail -1
변경일이 오래된 파일을 찾는 간단한 커맨드입니다.

---------------------------------------------------------------------------------------------------------------------------------------------------------

스프링 프레임워크(Spring Framework)는 Java 기반 애플리케이션 개발을 지원하는 오픈소스 애플리케이션 프레임워크로 간단히 스프링(Spring)이라고도 불립니다. 
스프링이 사용되기 이전에는 초기 기업에서 EJB(Enterprise Java Bean) 방식의 기술을 이용해서 Web Application 을 서비스했습니다. 
EJB는 데이터베이스 처리 및 트랜잭션 처리 등 기업용 애플리케이션 개발에 필요한 기술을 제공했는데요. 
특정 회사의 EJB 컨테이너(Oracle Weblogic, IBM WebSphere 등)가 없이는 기술이 구현이 어렵고 프로그래밍 모델이 복잡하며, 자동화된 테스트가 거의 불가능하다는 치명적인 단점을 가지고 있습니다. 
스프링은 이러한 EJB의 단점을 해결하여, 순수 자바 객체(POJO)만을 사용하여 복잡성을 제거하고, 단순하고 가벼운 코드로 기업용 애플리케이션을 개발하기 위한 목적으로 개발된 프레임워크(Framework)입니다. 

POJO(Plain Old Java Object)는 특정한 규약이나 프레임워크에 종속되지 않는 간단하고 순수한 자바 객체를 의미합니다. 
POJO는 객체지향 개발의 원칙에 충실한 객체를 말하며, 특정한 제약이나 요구사항에 종속되지 않고 유연하고 확장 가능한 코드를 작성할 수 있도록 도와줍니다.
스프링은 기존의 EJB가 제공하던 기업용 애플리케이션을 개발하기 위한 다양한 기능과 복잡한 시스템이나 개념을 간소화하며 개발자가 애플리케이션을 더 쉽게 개발하고 관리할 수 있도록 돕습니다.

스프링 부트(Spring Boot)는 스프링의 문제점을 해결해 주기 위해 개발된 스프링의 프레임워크로 개발자들이 더 쉽고 빠르게 스프링 애플리케이션을 개발하도록 도와주기 위해 개발되었습니다.  
개발 초기에 "스프링 부트 스타터"라는 프로젝트명으로 시작되었는데요. 이름에서도 느껴지듯이 간단한 설정과 구성을 통해 스프링 애플리케이션의 개발을 빠르게 시작할 수 있도록 도와주는 프로젝트였습니다. 

시간이 흘러 프로젝트명은 "스프링 부트"로 변경되었고, 2014년 4월에 공식적으로 스프링 부트1.0이 출시되었습니다.
스프링 부트는 기업용 애플리케이션 개발을 더 쉽고 빠르게 하도록 도와주며, 모니터링, 건강 상태 확인(Health Check), 로깅, 설정관리 등 운영에 필요한 필수 기능을 내장하고 있는 프레임워크로 
어떤 특징을 갖고 있는지 함께 살펴보겠습니다.
스프링 부트는 기본적인 설정과 보일러 플레이트 코드(여러 곳에서 재사용되는 코드) 작성을 최소화하고, 
자동 설정과 컨벤션을 통해 개발자들이 빠르게 애플리케이션을 개발할 수 있도록 지원하는 스프링 프레임워크입니다. 
스프링 부트를 사용하면 내장형 서버를 사용하여 별도의 웹 애플리케이션 서버(Web Application Server)를 설치할 필요 없이 애플리케이션을 실행할 수 있으며, 
다양한 스프링 프레임워크 기능과 라이브러리, 서드파티 라이브러리와의 통합을 간편하게 구성할 수 있는데요. 
스프링 부트는 스프링 기반의 웹 애플리케이션, 마이크로 서비스, RESTful API 등 다양한 애플리케이션의 개발을 간편하게 해주는 도구로 폭넓게 사용되고 있습니다. 
주요 특징을 요약하면 다음과 같습니다.


간결한 설정
스프링 부트는 번거로운 XML 설정이 필요 없으며, 최소한의 설정으로 Spring을 사용할 수 있고, 기본적인 설정을 자동으로 처리하므로 개발자가 많은 설정 작업을 하지 않아도 됩니다. 
설정으로 인한 불편사항을 해소하여 개발자는 애플리케이션 개발에 집중할 수 있습니다.

내장 서버
스프링 부트는 내장된 서버(내장 Tomcat, Jetty, Undertow)를 제공하여 별도의 서버 설정 없이 애플리케이션을 실행할 수 있습니다. 
배포를 위해 War 파일을 생성해서 Tomcat에 배포할 필요 없으며, JAR 파일에는 모든 의존성 라이브러리가 포함되어 있어 외부 서버 없이도 애플리케이션을 실행할 수 있습니다. 
이는 애플리케이션의 배포와 관리를 간편하게 만들어 줍니다.

의존성 관리 간소화
스프링 부트는 여러 3rd party 라이브러리를 사용할 때, 발생하는 라이브러리 버전 충돌로 인한 문제를 해결하기 위해서, 이미 테스트된 여러 라이브러리들의 묶음 패키지를 제공합니다.
3rd party 의존성 관리를 용이하게 하기 위한 ‘starter’ 의존성 통합 모듈을 제공하여 Maven/Gradel 설정 시 버전 관리가 간편합니다. 
스프링 부트에서 제공하는 의존성 세트를 통해 개발자는 버전 충돌이나 복잡한 의존성 설정에 대해 걱정하지 않고 필요한 의존성을 쉽게 지정할 수 있습니다.

운영 편의성
스프링 부트는 애플리케이션의 상태 모니터링, 로깅, 보안 설정 등 운영에 필요한 기능들을 제공합니다. 이를 통해 애플리케이션의 운영과 관리가 편리해지고 안정성이 향상됩니다. 
스프링 부트는 스프링(Spring Legacy)의 장점은 그대로 계승하면서, 기존의 문제가 되는 부분을 보완하여 기업용 애플리케이션의 개발 생산성 및 서비스 운영, 성능을 모두 해결해 줄 수 있습니다.  

---------------------------------------------------------------------------------------------------------------------------------------------------------
JSON (JavaScript Object Notation)은 경량의 DATA-교환 형식이다. 
이 형식은 사람이 읽고 쓰기에 용이하며, 기계가 분석하고 생성함에도 용이하다. JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999의 일부에 토대를 두고 있다. 
JSON은 완벽하게 언어로 부터 독립적이지만 C-family 언어 - C, C++, C#, Java, JavaScript, Perl, Python 그외 다수 - 의 프로그래머들에게 친숙한 관습을 사용하는 텍스트 형식이다. 
이러한 속성들이 JSON을 이상적인 DATA-교환 언어로 만들고 있다.

JSON은 두개의 구조를 기본으로 두고 있다:

name/value 형태의 쌍으로 collection 타입. 다양한 언어들에서, 이는 object, record, struct(구조체), dictionary, hash table, 키가 있는 list, 또는 연상배열로서 실현 되었다.
값들의 순서화된 리스트. 대부분의 언어들에서, 이는 array, vector, list, 또는 sequence로서 실현 되었다.
이러한 것들은 보편적인 DATA 구조이다. 사실상 모든 현대의 프로그래밍 언어들은 어떠한 형태로든 이것들을 지원한다. 
프로그래밍 언어들을 이용하여 호환성 있는 DATA 형식이 이러한 구조들을 근간에 두고 있는 것은 당연하다.

JSON 에서, 이러한 형식들을 가져간다:

object는 name/value 쌍들의 비순서화된 SET이다. 
object는 {좌 중괄호로 시작하고 }우 중괄호로 끝내어 표현한다. 각 name 뒤에 :colon을 붙이고 ,comma로 name/value 쌍들 간을 구분한다.

ex) jsonStr: {"address":"경기도 안성시 미양면 천문대길 60 1004 ","snd_zip":"12730","rcv_zip":"17604","msg_key":"","client_id":"CJMALL"}

---------------------------------------------------------------------------------------------------------------------------------------------------------
JPA(Java Persistence API)란?
자바에서 객체를 데이터베이스에 저장하고 관리하기 위한 인터페이스와 기능을 제공하는 API.
JPA를 사용하면 객체와 관계형 데이터베이스 간의 매핑을 손쉽게 처리할 수 있으며
데이터베이스의 CRUD(Create, Read, Update, Delete) 작업을 간편하게 수행할 수 있다.

출처: https://ccomccomhan.tistory.com/131 [[꼼꼼한 개발자] 꼼코더:티스토리]

JPA는 자바 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음이다. 
그 말은 즉, 실제적으로 구현된것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크이다. JPA를 구현한 대표적인 오픈소스로는 Hibernate가 있다.

ORM(Object-Relational Mapping)
우리가 일반 적으로 알고 있는 애플리케이션 Class와 RDB(Relational DataBase)의 테이블을 매핑(연결)한다는 뜻이며, 기술적으로는 어플리케이션의 객체를 RDB 테이블에 자동으로 영속화 해주는 것이라고 보면된다.

<장점>
SQL문이 아닌 Method를 통해 DB를 조작할 수 있어, 개발자는 객체 모델을 이용하여 비즈니스 로직을 구성하는데만 집중할 수 있음.
(내부적으로는 쿼리를 생성하여 DB를 조작함. 하지만 개발자가 이를 신경 쓰지 않아도됨)
Query와 같이 필요한 선언문, 할당 등의 부수적인 코드가 줄어들어, 각종 객체에 대한 코드를 별도로 작성하여 코드의 가독성을 높임
객체지향적인 코드 작성이 가능하다. 오직 객체지향적 접근만 고려하면 되기때문에 생산성 증가
매핑하는 정보가 Class로 명시 되었기 때문에 ERD를 보는 의존도를 낮출 수 있고 유지보수 및 리팩토링에 유리
예를들어 기존 방식에서 MySQL 데이터베이스를 사용하다가 PostgreSQL로 변환한다고 가정해보면, 새로 쿼리를 짜야하는 경우가 생김. 이런 경우에 ORM을 사용한다면 쿼리를 수정할 필요가 없음

<단점>
프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있음
복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있음
학습비용이 비쌈

---------------------------------------------------------------------------------------------------------------------------------------------------------
PaaS (Platform as a Service)는 클라우드 컴퓨팅 모델의 하나로, 개발자가 애플리케이션을 개발, 실행, 관리하는 데 필요한 모든 플랫폼(운영 체제, 데이터베이스, 개발 도구 등)을 제공하는 서비스입니다. 
개발자는 서버나 인프라를 직접 관리할 필요 없이 PaaS를 통해 애플리케이션 개발에 집중할 수 있습니다. 

---------------------------------------------------------------------------------------------------------------------------------------------------------
BTS의 주요 업무 서비스를 컨테이너로 구성하는 OpenShift 영역과 DB서버, SSO 서버와 같은 서비스를 지원하고 관리하기 위한 기능서버들이 위치한 물리 및 VM 서버 영역으로 크게 구분됨
BTS 서비스의 사용자 접점은 OpenShift Router이며 화면 및 정적 컨텐츠는 VM으로 구성된 UI서버, API는 서비스 영역 Endpoint인 Istio Ingress Gateway로 각각 호출됨
안정적 성능을 윈하여 OpenShift Worker Node와 DB서버는 Bare-metal 서버로 구성되며, OpenShift 관리 Node 및 나머지 서비스 지원 서버들은 VM으로 구성됨(CJENM 제공)
DB서버는 상품 서비스를 OSS DB로 분리하여 신규 구성하고, 나머지 업무 영역은 기존의 통합 DB를 사용
Legacy 시스템과 BTS는 기존 방식대로 EAI 체계 및 요구되는 프로토콜로 연계하며, 필요 시 BTS API를 호출하여 연계할 수 있음
기본적으로 외부 시스템에서 BTS로의 직접적인 연계는 없으며, DMZ에 외부용 Proxy를 구성하여 BTS API를 호출할 수 있도록 구성

---------------------------------------------------------------------------------------------------------------------------------------------------------
<T> => ex)Json<T>
TypeScript 는 단순하게 JavaScript에서 Type을 추가해준 언어이다.

하지만 TypeScript를 쓰면서 <T>라는 새로운 아이를 만나게 된다.
처음에는 <T>를 만나거나 쓸 일이 없어 단순하게 넘겼지만 TypeScript로 개발을 하면서 자연스럽게 <T>를 만나게 되었다.

그럼 <T>가 무엇이고 왜 TypeScript에서는 이걸 쓰는지에 대해서 이야기해보도록 하자.

쓰는 이유
JavaScript는 다른 언어들과 달리 type을 입력하지 않기 때문에 자유롭다.
그만큼 위험부담이 높기 때문에 JavaScript 개발자들은 필수적으로 TypeScript를 이용해서 type에 따른 위험 요소를 줄이고자 한다.
TypeScript는 함수나 클라스를 사용하기 위해서는 미리 Type을 지정해줘야 한다.
그렇지만 함수나 클래스를 정의하는 시점에 Type을 선언하기 어렵거나 번거로운 경우가 있다.

어떤 경우인지 아래 코드를 보면서 이야기해보자.

const useGeneric = <T>(a: T) => {
    if(typeof a === 'string') {
        console.log('string입니다.')
    } else if(typeof a === 'number'){
        console.log('number입니다.')
    }
    ...
}
  
useGeneric('i')
사용자로부터 입력한 값에 따라 결과값이 달라지는 함수를 작성했다.
어떤 값을 useGeneric에 넣어도 Type으로 오류가 날 이유가 없다.
선언 시점이 아닌 생성한 시점에서 타입을 부여하기 때문에 효율적인 코드를 작성할 수 있다.


쓰지 않는다면

const useGeneric = (a:number ) => {
    if(typeof a === 'string') {
        console.log('string입니다.')
    } else if(typeof a === 'number'){
        console.log('number입니다.')
    }
    ...
}
  
useGeneric('i') => 오류발생

첫번째는 Type을 미리 지정한다.
Type을 미리 지정할 경우 위와 같이 다른 Type을 사용할 경우 오류가 발생한다.
그렇기 때문에 범용성이 많이 떨어진다.

두번째는 any를 이용한다.

TypeScript에서 any를 쓰겠다는 것은 그냥 TypeScript를 안 쓰겠다는 말과 같다 ??

모든 타입 검증을 무력화하기 때문에 any 자체를 안 쓰는것이 좋다.


개념
이처럼 Type 검증을 유용하게 해주는 아이를 Generuc 즉, 제너릭이라고 명칭한다.
제너릭을 쓰는 방법은 아래와 같다.
 

// 위와 아래가 같은거다
const generic = <T>(b: T) => {
    ...
}

const generic = <U>(b: U) => {
    ...
}
제너릭을 쓰고 싶다면 < >로 표시해주면 된다.
<T>에서 T는 관용적으로 사용하지만 원한다면 다른 이름으로 해줘도 된다!

제네릭(Generic)은 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미한다. 
한마디로 특정(Specific) 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반(Generic) 타입이라는 것이다.

ckarh> https://st-lab.tistory.com/153

Generic(제네릭)의 장점

1. 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.
2. 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.
3. 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.

Generic(제네릭) 사용방법
보통 제네릭은 아래 표의 타입들이 많이 쓰인다. 

타입	설명
<T>	Type
<E>	Element
<K>	Key
<V>	Value
<N>	Number

물론 반드시 한 글자일 필요는 없다. 또한 설명과 반드시 일치해야 할 필요도 없다. 
예로들어 <Ele>라고 해도 전혀 무방하다. 다만 대중적으로 통하는 통상적인 선언이 가장 편하기 때문에 위와같은 암묵적(?)인 규칙이 있을 뿐이다.

그럼 각 상황별 선언 및 생성 방법을 알아보자.

1. 클래스 및 인터페이스 선언
public class ClassName <T> { ... }
public interface InterfaceName <T> { ... }
 
기본적으로 제네릭 타입의 클래스나 인터페이스의 경우 위와같이 선언한다.
T 타입은 해당 블럭 { ... } 안에서까지 유효하다.

또한 여기서 더 나아가 제네릭 타입을 두 개로 둘 수도 있다. (대표적으로 타입 인자로 두 개 받는 대표적인 컬렉션인 HashMap을 생각해보자.)

public class ClassName <T, K> { ... }
public interface InterfaceName <T, K> { ... }
 
// HashMap의 경우 아래와 같이 선언되어있을 것이다.
public class HashMap <K, V> { ... }
 
이렇듯 데이터 타입을 외부로부터 지정할 수 있도록 할 수 있다.
그럼 이렇게 생성된 제네릭 클래스를 사용하고 싶을 것이다. 즉, 객체를 생성해야 하는데 이 때 구체적인 타입을 명시를 해주어야 하는 것이다.

public class ClassName <T, K> { ... }
public class Main {
	public static void main(String[] args) {
		ClassName<String, Integer> a = new ClassName<String, Integer>();
	}
}
 
위 예시대로라면 T는 String이 되고, K는 Integer가 된다.

지금까지는 제네릭의 가장 일반적인 예시들을 보여주었다. 
예로들어 타입을 T라고 하고 외부클래스에서 Integer을 파라미터로 보내면 T 는 Integer가 되고, String을 보내면 T는 String이 된다. 
만약 당신이 Student 라는 클래스를 만들었을 때 T 파라미터를 Student로 보내면 T는 Student가 된다. 즉, 제네릭은 참조 타입 모두 될 수 있다.

근데, 만약 특정 범위 내로 좁혀서 제한하고 싶다면 어떻게 해야할까? 

이 때 필요한 것이 바로 extends 와 super, 그리고 ?(물음표)다. ? 는 와일드 카드라고 해서 쉽게 말해 '알 수 없는 타입'이라는 의미다.
일단 먼저 예시를 보면서 말해보자면 이용할 때 크게 세 가지 방식이 있다. 바로 super 키워드와 extends 키워드, 마지막으로 ? 하나만 오는 경우다. 
코드로 보자면 다음과 같다. 

<K extends T>	// T와 T의 자손 타입만 가능 (K는 들어오는 타입으로 지정 됨)
<K super T>	// T와 T의 부모(조상) 타입만 가능 (K는 들어오는 타입으로 지정 됨)
 
<? extends T>	// T와 T의 자손 타입만 가능
<? super T>	// T와 T의 부모(조상) 타입만 가능
<?>		// 모든 타입 가능. <? extends Object>랑 같은 의미
 

보통 이해하기 쉽게 다음과 같이 부른다.

extends T : 상한 경계
? super T : 하한 경계
<?> : 와일드 카드(Wild card)

이 때 주의해야 할 게 있다. K extends T와 ? extends T는 비슷한 구조지만 차이점이 있다.
'유형 경계를 지정'하는 것은 같으나 경계가 지정되고 K는 특정 타입으로 지정이 되지만, ?는 타입이 지정되지 않는다는 의미다.

가장 쉬운 예시로 다음과 같은 예시가 있다.

/*
 * Number와 이를 상속하는 Integer, Short, Double, Long 등의
 * 타입이 지정될 수 있으며, 객체 혹은 메소드를 호출 할 경우 K는
 * 지정된 타입으로 변환이 된다.
 */
<K extends Number>
 
 
/*
 * Number와 이를 상속하는 Integer, Short, Double, Long 등의
 * 타입이 지정될 수 있으며, 객체 혹은 메소드를 호출 할 경우 지정 되는 타입이 없어
 * 타입 참조를 할 수는 없다.
 */
<? extends T>	// T와 T의 자손 타입만 가능
 
위와 같은 차이가 있다. 그렇기 때문에 특정 타입의 데이터를 조작하고자 할 경우에는 K 같이 특정 제네릭 인수로 지정을 해주어야 한다.  

1. <K extends T>, <? extends T>

이 것은 T 타입을 포함한 자식(자손) 타입만 가능하다는 의미다. 즉, 다음과 같은 경우들이 있다.

<T extends B>	// B와 C타입만 올 수 있음
<T extends E>	// E타입만 올 수 있음
<T extends A>	// A, B, C, D, E 타입이 올 수 있음
 
<? extends B>	// B와 C타입만 올 수 있음
<? extends E>	// E타입만 올 수 있음
<? extends A>	// A, B, C, D, E 타입이 올 수 있음
 

주석에 썼듯이 보면 알겠지만, 상한 한계. 즉 extends 뒤에 오는 타입이 최상위 타입으로 한계가 정해지는 것이다.
대표적인 예로는 제네릭 클래스에서 수를 표현하는 클래스만 받고 싶은 경우가 있다. 대표적인 Integer, Long, Byte, Double, Float, Short 같은 래퍼 클래스들은 Number 클래스를 상속 받는다.

즉,  Integer, Long, Byte, Double, Float, Short 같은 수를 표현하는 래퍼 클래스만으로 제한하고 싶은 경우 다음과 같이 쓸 수 있다.
public class ClassName <K extends Number> { ... }


2. <K super T>, <? super T>

이 것은 T 타입의 부모(조상) 타입만 가능하다는 의미다. 즉, 다음과 같은 경우들이 있다.
<K super B>	// B와 A타입만 올 수 있음
<K super E>	// E, D, A타입만 올 수 있음
<K super A>	// A타입만 올 수 있음
 
<? super B>	// B와 A타입만 올 수 있음
<? super E>	// E, D, A타입만 올 수 있음
<? super A>	// A타입만 올 수 있음
 

주석에 썼듯이 보면 알겠지만, 하한 한계. 즉 super 뒤에 오는 타입이 최하위 타입으로 한계가 정해지는 것이다.
대표적으로는 해당 객체가 업캐스팅(Up Casting)이 될 필요가 있을 때 사용한다.

예로들어 '과일'이라는 클래스가 있고 이 클래스를 각각 상속받는 '사과'클래스와 '딸기'클래스가 있다고 가정해보자.
이 때 각각의 사과와 딸기는 종류가 다르지만, 둘 다 '과일'로 보고 자료를 조작해야 할 수도 있다. 
(예로들면 과일 목록을 뽑는다거나 등등..) 그럴 때 '사과'를 '과일'로 캐스팅 해야 하는데, 과일이 상위 타입이므로 업캐스팅을 해야한다. 이럴 때 쓸 수 있는 것이 바로 super라는 것이다.

조금 더 현실성 있는 예제라면 제네릭 타입에 대한 객체비교가 있다.

public class ClassName <E extends Comparable<? super E>> { ... }


3. <?> (와일드 카드 : Wild Card)
마지막으로 와일드 카드다. 
이 와일드 카드 <?> 은 <? extends Object> 와 마찬가지라고 했다. Object는 자바에서의 모든 API 및 사용자 클래스의 최상위 타입이다. 한마디로 다음과 같은 의미나 마찬가지다.

public class ClassName { ... }
public class ClassName extends Object { ... } 
 
우리가 public class ClassName extends Object {} 를 묵시적으로 상속받는 것이나 다름이 없다.
한마디로 <?>은 무엇이냐. 어떤 타입이든 상관 없다는 의미다. 당신이 String을 받던 어떤 타입을 리턴 받던 알빠 아니라는 조금 과격한 얘기..
이는 보통 데이터가 아닌 '기능'의 사용에만 관심이 있는 경우에 <?>로 사용할 수 있다.

---------------------------------------------------------------------------------------------------------------------------------------------------------

JSP (Java Server Pages)는 자바 언어를 사용하여 서버 측에서 웹 페이지를 동적으로 생성하는 기술입니다. 즉, HTML에 자바 코드를 포함시켜 동적인 웹 페이지를 만들 수 있습니다. 힙냥. 
JSP의 주요 특징:
서버 사이드 스크립팅:
JSP는 서버에서 실행되는 스크립트 기술로, 클라이언트가 브라우저에 페이지를 요청하면 서버에서 JSP를 실행하여 동적인 웹 페이지를 생성하고 클라이언트로 전송합니다.
자바 통합:
JSP는 자바 언어를 사용하여 서버 측 로직을 구현할 수 있습니다. HTML에 자바 코드를 포함하여 동적인 콘텐츠를 생성하고, 사용자 입력을 처리하고, 데이터베이스와 상호 작용하는 등의 기능을 구현할 수 있습니다.
동적 콘텐츠 생성:
JSP는 사용자 입력, 데이터베이스 데이터, 기타 서버 측 정보를 활용하여 동적으로 웹 페이지를 생성합니다. 예를 들어, 사용자의 로그인 상태, 상품 목록, 검색 결과 등을 동적으로 표시할 수 있습니다.
간단한 사용:
JSP는 비교적 간단한 문법으로 웹 페이지를 만들 수 있습니다. HTML 태그와 자바 스크립트 태그를 함께 사용하여 웹 페이지를 구성할 수 있으며, JSP 태그를 사용하여 자바 로직을 포함시킬 수 있습니다. 
JSP의 활용:
웹 애플리케이션 개발:
JSP는 웹 애플리케이션의 프런트 엔드와 백 엔드 개발에 널리 사용됩니다. 웹 애플리케이션의 UI, 사용자 인터페이스, 데이터 처리 등을 JSP로 구현할 수 있습니다.
동적 웹 페이지 생성:
JSP는 동적인 웹 페이지를 생성하는 데 적합합니다. 사용자 입력, 데이터베이스 데이터, 기타 서버 측 정보를 활용하여 동적으로 웹 페이지를 생성할 수 있습니다.
웹 서버와 연동:
JSP는 웹 서버와 연동하여 웹 애플리케이션을 배포하고 실행할 수 있습니다. JSP는 웹 서버에서 실행되며, 웹 서버는 JSP를 실행하여 웹 페이지를 생성하고 클라이언트로 전송합니다. 
JSP의 단점:
복잡한 템플릿:
JSP는 자바 코드를 HTML에 포함시키기 때문에 템플릿이 복잡해지거나 가독성이 떨어질 수 있습니다.
개발 생산성:
JSP는 자바 코드를 포함시키기 때문에 HTML과 자바 코드를 번갈아 가면서 개발해야 해서 개발 생산성이 떨어질 수 있습니다.
테스트:
JSP는 서버에서 실행되기 때문에 웹 페이지를 테스트하기 어려울 수 있습니다. 
JSP 대신 사용할 수 있는 기술:
Thymeleaf:
Thymeleaf는 JSP보다 간단한 문법으로 웹 페이지를 만들 수 있는 템플릿 엔진입니다. JSP보다 템플릿이 간결하고 가독성이 높습니다.
Spring MVC:
Spring MVC는 웹 애플리케이션을 개발하기 위한 프레임워크로, JSP를 대체할 수 있습니다. Spring MVC는 JSP보다 개발 생산성이 높고, 테스트를 하기 쉽습니다.
HTML, CSS, JavaScript:
HTML, CSS, JavaScript는 웹 페이지를 만들기 위한 기본 기술입니다. JSP 없이도 HTML, CSS, JavaScript를 사용하여 웹 페이지를 만들 수 있습니다. 

현재는 JSP 사용률이 감소하고, Thymeleaf를 사용하는 추세가 증가하고 있다. JSP는 Java 코드를 HTML에 삽입하는 방식이어서 템플릿이 복잡해지기 쉽고, 특수한 태그와 
스크립트릿을 사용하기 때문에 브라우저에서 직접 보는 것이 어렵기 때문에 여러 가지로 훨씬 쉽고 편한 Thymeleaf를 두고 JSP를 사용할 이유가 없어졌기 때문이다
---------------------------------------------------------------------------------------------------------------------------------------------------------

Thymeleaf는 Java 기반의 현대적인 서버사이드 템플릿 엔진으로, 웹(서블릿 기반) 환경과 웹이 아닌 환경 모두에서 작동할 수 있는 Java XML / XHTML / HTML5 템플릿 엔진이다. 
HTML, XML, JavaScript, CSS 등을 동적으로 생성하고 조작하는 데 사용된다. Spring Framework와 자연스럽게 통합되며, 서버사이드 애플리케이션에서 뷰를 렌더링하는 데 널리 활용되고 있다.

Thymeleaf는 웹 애플리케이션에서 JSP(Java Server Pages)를 완전히 대체하는 것을 목표로 하며, 자연 템플릿(Natural Templates)이라는 개념을 도입하여, 
템플릿 파일을 브라우저에서 직접 열어도 올바른 정적 페이지로 표시되도록 설계되었다. 이를 통해 디자이너와 개발자가 동일한 템플릿 파일을 공유하며 작업하는 것이 가능하다.

Thymeleaf는 Apache License 2.0에 따라 라이센스가 부여된 오픈 소스 소프트웨어이다.
---------------------------------------------------------------------------------------------------------------------------------------------------------

MVC는 소프트웨어 디자인 패턴으로, Model, View, Controller의 세 가지 구성 요소를 분리하여 애플리케이션 개발에 사용됩니다. 
Model은 데이터를 관리하고, View는 사용자 인터페이스를 표시하며, Controller는 사용자 입력을 처리하고 모델과 뷰를 연결합니다. 

MVC 패턴의 핵심 구성 요소:
Model (모델): 데이터와 비즈니스 로직을 담당합니다.
View (뷰): 사용자에게 데이터를 보여주는 역할을 합니다.
Controller (컨트롤러): 사용자 입력과 모델의 상호 작용을 처리합니다. 
MVC 패턴의 장점:
관심사 분리:
각 구성 요소의 역할이 명확하게 구분되어 코드의 가독성 및 유지 보수성이 향상됩니다. 
유연성:
구성 요소 간의 결합도가 낮아 애플리케이션의 변경 및 확장이 용이합니다. 
코드 재사용:
각 구성 요소를 독립적으로 개발하고 재사용할 수 있습니다. 
협업:
개발 팀원 간의 협업이 용이해집니다. 
MVC 패턴의 예시:
MVC 패턴은 웹 애플리케이션, 모바일 앱, 데스크톱 애플리케이션 등 다양한 소프트웨어 개발 분야에서 사용됩니다. 
예를 들어, 웹 애플리케이션에서 MVC 패턴을 사용하면 사용자 인터페이스(뷰)를 변경하더라도 데이터 모델(모델)이나 비즈니스 로직(컨트롤러)을 변경하지 않고도 개발할 수 있습니다. 
참고:
MVC 패턴은 소프트웨어 디자인 패턴 중 하나이며, 이 패턴을 사용하는 프레임워크나 라이브러리도 있습니다. 
Spring Framework와 같이 MVC 패턴을 기반으로 한 프레임워크도 있습니다. 
MVC 패턴과 관련된 용어:
MVC 1 패턴: Model과 View가 직접적인 상호 작용을 하는 패턴 
MVC 2 패턴: View와 Model이 Controller를 통해 간접적으로 상호 작용하는 패턴 
MVC 디자인 패턴: 소프트웨어 개발에서 사용되는 패턴 중 하나 
관심사 분리: MVC 패턴의 핵심 원칙 중 하나 
유지보수: MVC 패턴을 사용하면 애플리케이션의 유지보수가 용이해집니다. 
코드 재사용성: MVC 패턴을 사용하면 코드의 재사용성이 높아집니다. 
확장성: MVC 패턴을 사용하면 애플리케이션의 확장이 용이해집니다. 
협업: MVC 패턴을 사용하면 개발 팀원 간의 협업이 용이해집니다. 
애플리케이션: MVC 패턴은 웹 애플리케이션, 모바일 앱, 데스크톱 애플리케이션 등 다양한 소프트웨어 애플리케이션에 사용됩니다. 
프레임워크: MVC 패턴을 기반으로 한 프레임워크는 개발 생산성을 높여줍니다. 
라이브러리: MVC 패턴을 기반으로 한 라이브러리도 개발 생산성을 높여줍니다

---------------------------------------------------------------------------------------------------------------------------------------------------------
https://yummy0102.tistory.com/550
EJB(Enterprise Java Beans)를 공부하기 전에 먼저 Java Beans에 대해 간단하게 알아보자

Java Bean(자바 빈)
Java Bean이란 Java로 작성된 소프트웨어 컴포넌트를 말한다
Java는 프로그램 기본 단위가 클래스이고, Java Bean은 그 클래스들이 복합적으로 이루어진 구조를 말한다
Java Bean은 데이터를 표현하는 것을 목적으로 하는 자바 클래스로, 컴포넌트와 비슷한 의미로도 사용된다
Java Bean은 단순히 Java 언어로 작성된 클래스를 의미하는 것이 아니라, 아래의 규격에 따라 만들어진 클래스를 의미한다
 
Java Bean의 규격
클래스는 패키지화 해야 한다
멤버 변수는 프로퍼티(Property)라 칭한다
클래스는 필요에 따라 직렬화가 가능하다
프로퍼티의 접근자는 private이다
프로퍼티마다 getter/setter가 존재해야 하며, 그 이름은 각각 get/set으로 시작해야 한다
위의 프로퍼티 getter/setter 메서드의 접근자는 public이어야 한다
외부에서 프로퍼티에 접근은 메서드를 통해서만 한다
프로퍼티는 반드시 읽기/쓰기가 가능해야 하지만, 읽기 전용인 경우 getter만 정의 가능하다
getter의 경우 파라미터가 존재하지 않아야 하고, setter의 경우 한 개 이상의 파라미터가 존재한다
프로퍼티의 type이 boolean인 경우 get 메서드 대신 is 메서드를 사용해도 된다
 
EJB (Enterprise Java Beans)
기업환경의 시스템을 구현하기 위한 서버 측 컴포넌트 모델이다
EJB는 애플리케이션 업무 로직을 갖고 있는 서버 애플리케이션이다
EJB는 비즈니스 객체들을 관리하는 컨테이너 기술, 설정에 의한 트랜잭션 기술 등이 담겨 있었다
2000년대 초반에는 EJB라는 개념이 획기적이었고, Java 진영에서 표준으로 인정한 기술이기 때문에 많이 사용되었다
EJB vs Java Bean
- 둘은 용어가 비슷하고 Sun에서 만든 것은 같으나, 만들어진 목적이 다르고 주로 동작하는 위치도 다르다
- Java Bean은 비주얼 개발환경에서 사용되는 재사용 가능한 컴포넌트이며, EJB는 서버 쪽 비즈니스 애플리케이션에 사용되는 분산 객체 컴포넌트 모델이다
- 또한 EJB는 오직 서버에서만 동작하지만, Java Bean은 클라이언트에서 서버로 통신하는 경로에서 사용된다
 
EJB의 등장

기업의 IT 시스템 규모가 점점 커지고 복잡성 또한 증가하면서 많은 사용자들의 요구를 빠르고 안정적이게 처리하기 위한 다양한 기술 (트랜잭션, 멀티 쓰레딩, 리소스 풀링, 보안 등)이 요구되기  시작했따
하지만 애플리케이션 개발자가 비즈니스 로직 뿐만 아니라 위에 언급한 기술들을 모두 고려하여 개발하기는 쉽지 않다
이를 해결하지 위해 등장한 기술이 바로 EJB이다
EJB는 구조가 복잡한 대규모 시스템의 분산 객체 환경을 쉽게 구현하기 위해 등장하였다
EJB의 등장 이후 EJB 1.0의 스펙이 제시한 EJB의 비전은 다음과 같다
 

EJB는 애플리케이션 개발을 쉽게 만들어준다
애플리케이션 개발자는 로우 레벨의 기술들에 관심을 가질 필요도 없다

즉, EJB를 사용하면 개발자들은 도메인과 비즈니스 로직에만 집중하면 된다는 것이었다
EJB는 독립적으로 개발한 컴포넌트들을 서버에 자유롭게 배포하고 서로 연동해 사용하게 하는 컴포넌트 기반의 개발 모델을 제시한다
 
EJB의 구조
본격적으로 EJB는 거대 규모 시스템 구축을 위한 컴포넌트 모델이다
이 때 컴포넌트 모델이란, 대략 각각의 소프트웨어를 독립적인 모듈로 제작하여 재사용과 호환성을 높이는 개념이다
일반적으로 사용되는 Jaa EE의 API로 클라이언트가 볼 수 있는 화면단 로직은 JSP가, 비즈니스 로직은 EJB가 구현하는 구조로 구성되어 있다
또한 비즈니스 로직을 구현한 것을 Enterprise Bean이라고 부르며 Database 처리, Transaction 처리와 같은 시스템 서비스를 구현한 부분을 컨테이너라고 부른다
EJB는 크게 Enterprise Bean, Container, EJB Server, Client application으로 구성된다

EJB 구성
1) Enterprise Bean

비즈니스 로직을 실행하는 서버 컴포넌트로, 보통 2-3가지의 모델을 갖는다

-Session Bean (세션 빈)
DB 연동 없이 구동이 가능하다
주로 로직이 위치한다

-Entity Bean (엔티티 빈)
데이터베이스의 데이터 I/O 전반을 관리하는 객체
select, insert, update, delete 를 수행한다
DB 관련 쿼리는 자동으로 만들어지고 개발자는 고급 업무 처리에 집중할 수 있다
DB가 수정되면 코드 수정 없이 다시 배포가 가능하다
클라이언트가 Session Bean을 호출하고 Session Bean이 Entity Bean을 호출하며 데이터베이스에 접근하는 구조이다

-Message-driven Bean (메시지 구동 빈)
JMS로 빈을 날려준다
 
2) Container

EJB 컨테이너는 Application Server 내에서 Enterprise Bean에 대한 런타임 환경을 제공한다
일반적으로 EJB와 Enterprise Bean 사이에 통신을 하게 해주는 역할을 한다고 이해할 수 있다
Servlet이 Apache Tomcat과 같은 Servlet Container에 올려서 서비스 되는 것처럼, EJB는 Weblogic, JBoss와 같은 EJB Container에 올려서 서비스 된다
보통 사용자는 클라이언트 어플리케이션을 사용하고, 이는 컨테이너를 경유해서 Enterprise Bean에 접근한다
컨테이너가 데이터베이스 처리와 트랜잭션 처리 등을 숨기기 위해 개발자와 그것들을 의미하지 않는 어플리케이션을 개발하는 것이 가능하다
EJB 컨테이너는 Enterprise Bean에 다음과 같은 서비스를 제공한다
필요 시 트랜잭션 시작 -> commit 또는 roll back
수신 요청에 대해 Enterprise Bean 인스턴스 풀을 준비 상태로 유지 보수 및 비활성 풀과 활성 상태 간 인스턴스 이동
Bean 내의 스레드 조건 충족 보장
Entity Bean의 인스턴스 변수와 지속 스토리지에 저장된 해당 데이터 항목의 자동 동기화
 
3) EJB Server

EJB Server는 컨테이너를 관리해서 EJB로서 필요한 시스템 서비스(데이터 베이스 처리, 트랜잭션 처리 등)를 구현한다
 
4) Client Application

EJB 구조를 사용함에 있어 이와 연결할 수 있는 클라이언트 단의 어플리케이션
종류로는 Java Applet, Java Application, Servlet, Java Server Pages(JSP) 가 있다
 
EJB의 특징
1.인스턴스 풀링
객체를 미리 생성하고 메모리에 저장하여 사용 준비 상태에서 서버가 동작한다
많은 동시 접속자에 대한 안정성을 지원한다
2.트랜잭션 처리
컨테이너가 자동으로 모든 메소드에 대한 트랜잭션 처리를 한다
안정적인 데이터 조작이 가능하다
3.퍼시스턴스 관리 (영속성,지속성 : 데이터를 생성한 프로그램의 실행이 종료되도 사라지지않는 데이터의 특성을 의미한다. 영속성을 가지지 않는 데이터는 단지 메모리에 존재해 프로그램이 종료되면 없어진다. 데이터가 영속성을 가지려면 파일 시스템, 데이터베이스를 활용해 구현하면 된다.)
빈즈의 상태를 메모리에서 사용여부에 따라 자동으로 활성화/비활성화를 관리해준다
Fat Client를 Thin Client로 n-Tier 시스템을 구축할 수 있다
EJB 컴포넌트들이 Loading되어 활동하는 서버 쪽 프로그램, 컴포넌트 생성 및 소멸, 라이프 사이클 보안, Threading 등의 서비스를 제공해준다
분산 기능을 지원한다
Weblogic, Websperer을 주로 사용하며, 국산은 제우스(jeus)를 사용한다
 
EJB의 한계
1.성능적 측면
EJB에서는 현실에서 1% 미만의 애플리케이션에서만 필요한 분산 트랜잭션을 위해 나머지 99%의 애플리케이션도 무거운 JTA 기반의 글로벌 트랜잭션 관리 기능을 사용해야 했다
즉, 특정 환경 및 기술에 종속적인 코드이다
또한 EJB 컴포넌트는 컨테이너 밖에서는 정상적으로 동작할 수 없으므로 개발자들은 끝도 없이 반복되는 수정-빌드-배포-테스트의 과정으로 많은 시간을 낭비해야 했고, 
간단한 기능에 대해서 조차 자동화된 테스트를 만드는 것은 거의 불가능했다
EJB는 분산 환경을 지원하기 위해 객체를 직렬화하는 과정에서 실행 속도의 저하가 발생한다
이러한 EJB의 원격 분산 모델은 시스템의 성능을 떨어뜨리고 서버의 복잡도만 증가시켰다

2.비용적 측면
게다가 EJB의 혜택을 얻기 위해 모든 기능이 다 필요하지도 않은 고가의 WAS를 구입해야 했고, 고급 IDE의 도움 없이 는 손쉽게 다룰 수 없는 복잡한 설정 파일 또한 필요했다
EJB의 가장 큰 문제점은 EJB 스펙을 따르는 비즈니스 오브젝트들은 객체지향적인 특징과 장점을 포기해야 했다는 것이다
결국 EJB는 낮은 생산성, 느린 성능, 불필요한 기술 복잡도 등으로 인해 자바의 엔터프이즈 개발에 대한 불신을 가중시켰다
 

POJO의 등장
위와 같은 EJB의 한계로 인해 마틴 파울러를 비롯한 많은 오피니언 리더들은 EJB와 같은 잘못 설계된 과도한 기술을 피하고, 
객체 지향 원리에 따라 만들어진 자바 언어의 기본 기술에 충실하게 비즈니스 로직을 구현하는 POJO 방식으로 돌아서야 한다고 주장했다
POJO란 Plain Old Java Object 방식의 약자로, 직역하자면 오래된 방식의 간단한 자바 오브젝트이다
Java EE등의 중량 프레임워크들을 사용하게 되면서, 해당 프레임워크에 종속된 무거운 객체를 만들게 된 것에 반발해 사용하게 된 용어이다
POJO의 취지는 자바를 자바답게, OOP를 OOP 답게 쓰자는 것이다!
 
POJO의 정의
지정된 클래스를 extends 하면 안된다
정의된 인터페이스를 implement 하면 안된다
정의된 Annotation을 포함하지 않는다
 
POJO의 장점
코드가 간결해진다
자동화 테스트에 유리하다
객체지향 설계가 가능하다
POJO의 단순한 구조는 Over Engineering으로 인한 복잡성을 해결하고, 모듈화시킬 수 있다
이러한 POJO의 장점을 살린 다양한 프레임워크들이 등장하였고, 그 중 하나가 바로 Spring 프레임워크이다!
 

Spring 컨테이너

위와 같이 복잡한 EJB의 컨테이너를 대체하기 위해서 등장한 것이 바로 Spring 컨테이너이다
Spring은 "자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크" 라고 정의된다
Spring 컨테이너는 특정 클래스를 상속하거나 인터페이스를 구현하지 않는 POJO를 사용하여 많은 복잡성이 제거되었다
평범한 자바 클래스를 이용하여 EJB의 기능을 유지하면서 복잡성을 제거해 코드가 가벼워졌고, 스프링에 특화된 인터페이스 구현을 요구하지 않는 등 자바 개발의 폭 넓은 간소화를 실현하였다
또한 스프링은 위의 그림과 같이 여러 객체들을 의존성 해결(DI) 및 제어(IoC)하며 객체들의 라이프 사이클을 관리해준다
Spring은 특정 기술에 종속되지 않고 객체를 관리할 수 있는 컨테이너를 제공하는 것이 스프링의 기본 철학이다
 

Spring 특징
크기와 부하의 측면에서 가볍다
제어의 역전(IoC)를 통해 어플리케이션의 느슨한 결합을 도모한다
관점 지향 프로그래밍(AOP)을 위한 풍부한 지원을 한다
애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(container)라고 할 수 있다
간단한 컴포넌트로 복잡한 애플리케이션ㅇ르 구성하고 설정할 수 있다
확장성이 높다
DI(의존성 주입)을 지원한다
POJO(Plain Old Java Object) 방식의 프레임워크이다
 

DI (Dependency Injection, 의존성 주입)
사용자가 직접 new 키워드를 사용하여 객체를 생성하지 않고, 외부(컨테이너)에서 생성된 객체를 주입받는 방식이다
의존하는 객체를 직접 생성하는 대신 스프링 컨테이너로부터 의존 객체를 주입(전달)받는 방식이다
의존 : A라는 클래스가 어떤 일을 하기 위해 B에 있는 기능을 사용하는 것으로 다른 객체에 의존하여 처리한다는 개념
주입 : 생성되어 있는 객체를 주입받는 방식으로 사용하게 되는 것을 말한다
?? 빈 설정 정보를 바탕으로 컨테이너가 자동으로 의존성을 주입한다
즉, 제어하는 주체가 바뀐다 (제어의 역전)
 
IoC (Inversion of Control, 제어의 역전)
객체(인스턴스)의 생성과 소멸 등 개발자가 직접 제어해야 하는 부분들을 프레임워크(컨테이너)가 대신 처리하는 것을 의미한다
제어의 주도권이 개발자에서 스프링 프레임워크로 넘어가기 때문에 제어의 역전이라고 한다
 
Hibernate
EJB에는 ORM 기술인 Entity Bean 기술을 가지고 있었다
Spring 컨테이너와 마찬가지로 EJB의 Entity Bean 기술을 위해 Hibernate가 등장하였고, 현재 JPA 표준 인터페이스의 구현체 중 가장 많이 사용되고 있다
 
<ejb>
많은 동시 접속자에 대한 안정성을 지원
컨테이너가 자동으로 모든 메소드에 대한 트랜잭션 처리하기 때문에 안정적인 데이터 조작이 가능하고
분산 기능을 지원

무겁다 :
1% 미만의 애플리케이션에서만 필요한 분산 트랜잭션을 위해 나머지 99%의 애플리케이션도 무거운 JTA((Java Transaction API) 기반의 글로벌 트랜잭션 관리 기능을 사용해야 하고
특정 환경과 기술에 종속되어 있고 테스트가 어렵다. 
개발시 수정되는 파일이 많다
낮은 생산성, 느린 성능, 불필요한 기술 복잡도 등의 단점이 있다

<spring>
가볍다
코드가 간결해진다
자동화 테스트에 유리하다
객체지향 설계가 가능하다

객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 프로그램 설계 방법론의 일종으로 명령형 프로그래밍에 속한다.
프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체(object)'라는 기본 단위로 나누고 이들의 상호 작용으로 서술하는 방식이다.
객체란 '메소드, 변수'를 가지며 특정 역할을 수행하도록 인간이 정의한 추상적인 개념이다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
스토리지 시스템이란?
단일 디스크로 처리할 수 없는 용량을 저장하기 위해 디스크를 묶어서 논리적으로 사용하는 기술이다.
스토리지 구성은 서버와 저장장치를 연결하는 방법이다.

SAN이란 무엇인가요?
SAN(Storage Area Network)은 서버, 스토리지 시스템, 네트워킹 스위치, 소프트웨어 및 서비스를 결합하여 특정 환경에 맞게 조정된 전용 네트워크입니다.


https://sunrise-min.tistory.com/entry/NAS와-SAN-Storage의-차이

https://tech.gluesys.com/blog/2019/12/02/storage_1_intro.html
목차
데이터 스토리지
SAN: Storage Area Network
NAS: Network Attached Storage
SAN과 NAS의 용도
유니파이드 스토리지?
마치며
 

데이터 스토리지
전세계 9000만명 이상 되는 넷플릭스 서비스 이용자들은 매주 10억 시간 이상 영화나 드라마를 시청한다고 합니다. 
넷플릭스 비디오 서비스는 세계 각지의 AWS 데이터센터를 통해 끊김 없이 스트리밍 되며, 시청자들의 취향 정보를 빅데이터로 수집해 비디오 추천 서비스를 제공합니다. 
사실 이러한 서비스는 21세기를 살아가는 저희에게 당연하다고도 생각될 수 있는데요, 사실 이 경지에 이르기까지는 많은 기술적 발전이 요구되었습니다. 
그 중 하나가 바로 데이터 스토리지 기술의 발전입니다.

데이터 스토리지란 말 그대로 데이터(정보)를 저장하는 공간을 말합니다. 
AWS나 구글 데이터센터에 무수히 꽂혀 있는 하드디스크에서 지금은 거의 사용되지 않는 플로피 디스크까지 모두 아울러 데이터 스토리지라고 할 수 있습니다.


<기업용 디스크 스토리지의 과거와 현재>
 
데이터 스토리지의 종류는 기술의 발전에 따라 변화해 왔고 사용하는 방식 또한 바뀌어 왔습니다. 
초창기 서버에는 저희가 아는 RAM과 하드디스크, 즉 주 기억장치(primary storage)와 보조 기억장치(secondary storage)가 구분되어 있지 않았습니다. 
하지만 늘어나는 용량에 맞추다 보니 공간적인 한계에 봉착했고, 그 결과 구분된 스토리지 시스템을 가진 보조 기억장치가 탄생했습니다. 
이는 저희가 아는 직접 연결 스토리지(Direct-attached Storage, 이하 DAS) 개념의 첫 사례가 됩니다. 이와 같이 서버와 스토리지를 구분함으로써 
업무 효율을 위해 보다 정교하고 복잡한 아키텍처를 구성할 수 있게 되었습니다.


SAN: Storage Area Network
하드디스크의 용량 증가와 소형화가 진행되면서 공간 효율적인 서버를 구성할 수 있게 되었지만 서버의 용량 효율이 문제였습니다. 
서버의 스토리지 용량을 추가해야 할 경우, 부족분을 채우기 위해 새 디스크를 추가하거나 여유 공간이 있는 다른 서버에서 디스크를 물리적으로 빼서 추가해야 했습니다. 
이러한 불편함을 해소하기 위해 스토리지 영역 네트워크(Storage Area Network, 이하 SAN)가 고안되었습니다.


개요
SAN 방식은 여러 스토리지를 하나의 네트워크에 연결시키고, 이 네트워크에 서버를 연결해 스토리지에 접속한다는 개념입니다. 
네트워크에 묶인 스토리지들은 가상으로 중앙화된 논리 볼륨(logical volume)을 형성하고, 필요에 따라 각 서버에 공간을 논리적으로 할당할 수 있습니다. 
사용자는 LUN(Logical Unit Number)이라는 고유 번호를 통해 가상으로 할당된 디스크 드라이브에 연결됩니다.
 

구성
SAN 환경을 구성하기 위해서는 SAN 스위치라는 기기를 필요로 하게 됩니다. 
SAN 스위치는 위에서 설명 드렸던 개념을 구현하기 위해 스토리지와 서버를 중계하는 역할을 합니다. 
SAN 방식에서는 위 그림과 같이 각 서버와 스토리지를 광 케이블로 SAN 스위치와 연결해 데이터를 주고 받습니다.

SAN의 주요 스토리지 프로토콜1은 다음과 같습니다:

iSCSI (Internet Small Computer Systems Interface)
파이버 채널 (Fibre Channel)
iSER (iSCSI Extensions for RDMA)
 

블록 스토리지
SAN 환경에서는 파일을 저장하는 방식으로 블록 스토리지(block storage)라는 개념을 사용합니다. 
블록 스토리지는 데이터를 블록이라는 일정한 크기의 조각으로 나누어 저장하는 것을 말합니다. 
각 블록들은 저장된 위치(특정 스토리지 시스템의 특정 디스크)에 대한 주소를 가지고 있어 서버의 요청에 따라 블록들을 재구성해 하나의 데이터로 서버에 전달됩니다.

 

SAN의 장단점
장점	단점
광케이블을 사용하기 때문에 데이터 접근이 빠름 / 상대적으로 비쌈
필요에 따라서 성능과 용량을 확장하기가 용이함 / 이더넷 네트워크2와 광 케이블 네트워크3를 동시에 운영하기에 관리에 손이 많이 감
LAN을 사용하지 않아 네트워크 부하를 최소화할 수 있음 / 관리하는데 전문적인 인력이 필요함
가상화1 환경을 구축하기 적합함 / 블록 백업에 스토리지 공간이 더 요구됨
 

NAS: Network Attached Storage
사무실의 업무 환경이 종이에서 전자문서로 넘어가기 시작하면서 업무 문서나 자료들을 동시에 공유하고 수정하는 일이 많아졌습니다.
이처럼 스토리지에 접속하는 사용자가 증가하고 공유가 필요한 자료가 많아지면서 보다 쉽고 편리하게 데이터를 공유할 방법이 필요했습니다. 
이러한 배경 속에서 SAN과 함께 등장한 것이 바로 네트워크 결합 스토리지(Network-attached Storage, 이하 NAS)입니다.


개요
NAS도 마찬가지로 네트워크를 통해 서버나 클라이언트가 스토리지와 연결하지만 SAN과는 다르게 이더넷을 통해 연결하는 방식을 취합니다.
또한 스토리지를 SAN 스위치와 연결하지 않고 이더넷 케이블을 사용해 네트워크에 연결합니다. 
단적인 예로, 인터넷 공유기에 NAS를 연결하면 같은 이더넷 네트워크에 연결된 PC로 NAS에 접근할 수 있습니다. 
이처럼 범용적인 네트워크를 사용하는 관계로 설치나 유지 관리가 쉽지만, 같은 이더넷에 연결된 장비들과 네트워크 자원을 공유하기 때문에 
대역폭(전송속도)에 한계가 있을 수 있습니다.


구성
NAS는 자체적으로 파일4 서비스를 제공하며, 대표적으로 NFS나 CIFS와 같은 스토리지 프로토콜을 사용합니다. NAS의 주요 스토리지 프로토콜은 다음과 같습니다:

NFS (Network File System)
SMB/CIFS (Server Message Block/Common Internet File System)
FTP (File Transfer Protocol)
HTTP (Hypertext Transfer Protocol)
AFP (Apple Filing Protocol)
 

파일 시스템
NAS의 경우 블록보다 상위 개념인 파일(file)을 저장 단위로 하고 있습니다. 
파일은 폴더에 저장되며 하나의 폴더에 여러 하위 폴더가 겹겹이 존재하는 계층적(hierarchical) 구조를 가지고 있습니다. 
쉽게 생각해서 윈도우의 파일 탐색기를 떠올리면 됩니다. 
각 파일은 이름과 파일에 대한 정보를 나타내는 메타데이터를 가지며, 이 메타데이터를 활용해 어느 폴더의 하위 디렉토리에 파일이 있는지 알 수 있습니다.

NAS는 스토리지 시스템이 포함된 어플라이언스 형태와 스토리지 시스템이 포함 안 된 ‘게이트웨이’ 형태 두 가지 방식으로 구성될 수 있습니다. 
게이트웨이의 경우, 스토리지 부분을 SAN과 연결해서 블록 서비스와 함께 CIFS나 NFS와 같은 파일 서비스를 제공할 수 있습니다.

NAS의 장단점
장점	단점
기본적으로 구축되어 있는 이더넷 네트워크에 스토리지를 연결하면 되기 때문에 인프라 구축 비용이 따로 없음 / 이더넷 케이블을 사용하기 때문에 광케이블에 비해 전송 속도가 느림
단순한 시스템 아키텍처 구조로 유지 관리가 비교적 편함 / 공유 네트워크를 사용해 대역폭에 제한이 있고, 데이터를 IP 패킷으로 캡슐화5하는 부가적인 과정으로 속도 지연이 발생함에 따라 네트워크 병목에 취약함
스케일 아웃 방식6의 NAS는 클러스터 구성이 가능해 성능과 용량을 동시에 높일 수 있음 / 스케일 업 방식7의 NAS는 성능과 용량 확장에 한계가 있음
 

SAN과 NAS의 용도
이와 같이 SAN과 NAS는 각각의 장단점이 있으며 그 쓰임새 또한 다양합니다. 아래와 같이 각각의 용도를 소개해 보고자 합니다.

SAN
데이터베이스8: 온라인 금융 거래와 같이 빠른 속도를 요구하고 지연에 민감하며 대규모 데이터베이스를 다루는 환경에 적합합니다.
가상화 환경: 가상 머신과 호스트간 빠른 입출력 속도를 제공해야 하는 대규모 가상화 구축 환경에 적합합니다.
영상 편집: 후반 작업과 같은 영상 편집 작업에 있어서 빠른 전송 속도와 낮은 지연은 필수 불가결입니다. 
이 때문에 워크스테이션을 DAS로 직접 연결해 사용하는 경우도 있지만 효율성을 위해 고성능 SAN을 사용합니다.
 
NAS
파일 공유: NAS의 주 용도이며, 데이터를 중앙화하고 스토리지 공간을 효율적으로 활용하는데 적합합니다. 개인용부터 중소기업, 대기업 사무실까지 광범위하게 활용됩니다.
가상화 환경: 고성능 NAS의 경우 소규모 가상화 환경을 운영하거나 가상 데스크톱 환경9을 구축하는데 적합한 성능과 기능을 가지고 있습니다.
아카이브10: 스토리지 공간을 필요에 따라 확장할 수 있는 스케일 아웃 NAS의 경우 단순히 데이터를 묵혀 두는 방식의 아카이브가 아닌, 필요에 따라 종종 접근이 가능한 아카이브로서 적합합니다.
 

유니파이드 스토리지?
유니파이드 스토리지(멀티 프로토콜 스토리지라고도 한다)는 블록과 파일 프로토콜을 모두 지원해 말 그대로 SAN과 NAS를 합한 스토리지를 말합니다. 
하나의 유니파이드 스토리지 시스템은 파일 프로토콜인 CIFS와 NFS를 지원함과 동시에 iSCSI와 파이버 채널을 포함한 블록 수준의 프로토콜도 지원합니다.

유니파이드 스토리지의 장점은 스토리지 시스템을 도입할 때 비용과 수고를 아낄 수 있다는 점입니다. 
SAN이나 NAS를 따로 구매해 구축하는 것보다 
멀티 프로토콜 환경을 지원하는 유니파이드 스토리지로 스토리지 시스템을 구축하는 편이 비용 효율적이기 때문에 두 방식의 스토리지 인프라를 필요로 하는 중견급 기업으로부터 수요가 많습니다. 
다만 파일 입출력이 블록 입출력 성능에 영향을 끼치는 경우가 있기 때문에 고속 데이터 처리가 주 용도인 블록 스토리지로서의 성능을 제대로 발휘하기에는 한계가 있습니다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. 자료구조 & 알고리즘
- 배열, 해시맵, 스택, 큐, 그래프, 트리 등

- 효율적인 알고리즘 구현 능력 (시간 복잡도, 공간 복잡도 고려)

- 면접에서 자주 나오는 정렬 알고리즘(퀵 정렬, 머지 정렬 등)

2. 데이터베이스 최적화
- SQL 쿼리 튜닝, 인덱싱, 정규화 & 비정규화 개념

- NoSQL과 관계형 데이터베이스(RDBMS)의 차이 이해

- 대용량 데이터 처리 및 트랜잭션 관리

3. 네트워크 & 운영체제 개념
- HTTP/HTTPS, RESTful API, WebSocket, CORS 개념

- 멀티쓰레딩, 가상 메모리, 프로세스 & 스레드 차이

- 서버 부하 분산 및 로드 밸런싱 기법
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<자료구조>
배열, 해시맵, 스택, 큐, 그래프, 트리와 같은 자료구조는 데이터의 조직과 연산을 효율적으로 처리하기 위해 사용됩니다. 
배열은 인덱스를 통해 접근할 수 있는 선형적인 데이터 구조로, 
해시맵은 키-값 쌍을 저장하여 빠른 검색을 지원합니다. 
스택은 LIFO(Last In First Out) 방식으로 데이터를 관리하고, 
큐는 FIFO(First In First Out) 방식으로 데이터를 관리합니다. 
그래프는 노드와 간선으로 구성되어 관계를 표현하고, 
트리는 계층적인 구조를 나타냅니다.

1. 배열 (Array):
정해진 크기의 연속된 메모리 공간에 동일한 데이터 유형의 요소를 저장합니다.
인덱스를 통해 특정 요소에 직접 접근할 수 있습니다.
요소의 삽입 및 삭제가 어려울 수 있으며, 크기를 변경하기 어렵습니다.
2. 해시맵 (Hash Map):
키와 값을 저장하여 데이터를 관리합니다.
키를 기반으로 값을 빠르게 검색할 수 있습니다.
키를 이용하여 값을 삽입, 삭제, 수정할 수 있습니다.
3. 스택 (Stack):
마지막에 삽입된 요소가 먼저 제거되는 LIFO(Last In First Out) 방식으로 데이터를 관리합니다.
함수 호출, 표현식 평가 등 다양한 알고리즘에서 사용됩니다.
push, pop, peek 등의 연산을 지원합니다.
4. 큐 (Queue):
먼저 삽입된 요소가 먼저 제거되는 FIFO(First In First Out) 방식으로 데이터를 관리합니다.
작업 순서를 관리하거나, 데이터를 버퍼링하는 데 사용됩니다.
enqueue, dequeue, peek 등의 연산을 지원합니다.
5. 그래프 (Graph):
노드(vertex)와 간선(edge)으로 구성된 자료구조입니다.
노드 간의 관계를 표현하는 데 사용됩니다.
도로 네트워크, 소셜 네트워크 등 다양한 분야에서 활용됩니다.
6. 트리 (Tree):
계층적인 구조를 가지는 자료구조입니다.
부모 노드와 자식 노드 간의 관계를 표현합니다.
파일 시스템, 데이터베이스 인덱스 등 다양한 분야에서 활용됩니다.

<데이타베이스 정규화 & 비정규화 개념>

정규화 데이터베이스(Normalized Database)는 중복을 최소화하도록 설계된 데이터베이스를 말한다.
비정규화 데이터베이스(Denormalized Database)는 읽는 시간을 최적화하도록 설계된 데이터베이스를 말한다.

데이터베이스에서 정규화는 데이터베이스 구조를 설계하는 과정으로, 데이터 중복을 최소화하고 데이터 무결성을 유지하는 데 초점을 맞춥니다. 
비정규화는 데이터베이스의 성능을 향상시키기 위해 의도적으로 데이터 중복을 허용하는 기법입니다. 

정규화 (Normalization)
정의:
데이터 중복을 제거하고 데이터 무결성을 유지하는 데이터베이스 설계 과정.
목표:
데이터 일관성 유지, 저장 공간 효율성 향상, 데이터 수정 시 일관성 유지.
방법:
데이터베이스 테이블을 쪼개어 중복 데이터를 제거하고, 테이블 간 관계를 설정하는 방식.
장점:
데이터 무결성 유지, 저장 공간 효율성 향상, 데이터 수정 및 삭제 시 일관성 유지.
단점:
조인 쿼리가 많아져 성능이 저하될 수 있음. 
비정규화 (Denormalization)
정의: 데이터 중복을 허용하여 데이터베이스의 성능을 향상시키는 기법.
목표: 쿼리 성능 향상, 데이터 검색 속도 향상.
방법: 정규화된 데이터를 다시 통합하거나 중복하여 배치하는 방식.
장점: 쿼리 성능 향상, 데이터 검색 속도 향상.
단점: 데이터 무결성 위협, 저장 공간 증가, 데이터 수정 및 삭제 시 일관성 문제가 발생할 수 있음. 
정리:
정규화는 데이터의 구조와 무결성을 중요하게 생각하며, 비정규화는 성능을 중요하게 생각합니다. 
데이터베이스를 설계할 때는 정규화와 비정규화를 적절히 조합하여 사용해야 합니다. 
데이터의 특성과 사용 목적에 따라 정규화와 비정규화의 정도를 조절하여 데이터베이스를 설계하는 것이 중요합니다. 

<SQL 쿼리 튜닝, 인덱싱>
인덱스 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상

<NoSQL과 관계형 데이터베이스(RDBMS)의 차이 이해>
NoSQL과 관계형 데이터베이스(RDBMS)는 데이터베이스 유형으로, 각각의 특징과 용도에 따라 선택하여 사용됩니다. 
RDBMS는 SQL 언어를 사용하고, 
데이터 간 관계를 명확히 정의하여 데이터의 무결성을 유지합니다. 
반면, NoSQL은 SQL을 사용하지 않으며, 
동적인 스키마와 수평적 확장성을 갖춰 대규모 데이터 처리 및 빠른 응답 속도를 요구하는 애플리케이션에 적합합니다.
1. 스키마:
RDBMS:
고정된 스키마를 가지며, 데이터 구조가 변경될 때 스키마를 업데이트해야 합니다. 
NoSQL:
동적인 스키마 또는 스키마 없이 데이터를 저장하며, 새로운 필드를 쉽게 추가하거나 기존 필드를 변경할 수 있습니다. 
2. 데이터 관계:
RDBMS:
테이블 간 관계를 정의하고, 조인(join) 연산을 통해 데이터 간 연관성을 쉽게 파악할 수 있습니다. 
NoSQL:
테이블 간 관계를 명확히 정의하지 않으며, 일반적으로 테이블 간 조인이 불가능합니다. 
3. 데이터 모델:
RDBMS:
SQL 언어를 사용하여 테이블 형식으로 데이터를 저장합니다. 
NoSQL:
다양한 데이터 모델(문서, 키-값, 그래프 등)을 사용하여 데이터를 저장합니다. 
4. 확장성:
RDBMS:
수평적 확장이 가능하지만, NoSQL에 비해 복잡하고 어렵습니다. 
NoSQL:
수평적 확장성이 뛰어나 대규모 데이터를 쉽게 처리할 수 있습니다. 
5. ACID 트랜잭션:
RDBMS:
ACID(Atomicity, Consistency, Isolation, Durability) 속성을 보장하여 데이터의 무결성을 유지합니다.
NoSQL:
ACID 속성을 완화하거나 일부만 지원하는 경우가 많습니다. 
6. 사용 사례:
RDBMS:
금융 시스템, 전자 상거래 시스템 등 데이터의 무결성과 일관성이 중요한 애플리케이션에 적합합니다. 
NoSQL:
소셜 네트워크, 실시간 빅 데이터 처리 등 대규모 데이터 처리 및 빠른 응답 속도가 필요한 애플리케이션에 적합합니다. 
요약:
RDBMS는 안정성과 일관성을 중시하며, NoSQL은 유연성과 확장성을 중시합니다. 
각각의 장단점을 고려하여 애플리케이션의 요구사항에 맞는 데이터베이스를 선택하는 것이 중요합니다. 

<HTTP/HTTPS, RESTful API, WebSocket, CORS 개념>
HTTP와 HTTPS는 웹에서 데이터를 주고받는 기본적인 프로토콜이며, 
HTTPS는 데이터를 암호화하여 안전하게 전달합니다. 
RESTful API는 웹 서비스를 위한 디자인 스타일로, 상태 전송 없이 리소스 중심의 API를 제공합니다. 
WebSocket은 실시간 통신을 위한 기술로, 클라이언트와 서버 간의 양방향 통신을 가능하게 합니다. 
CORS는 웹 애플리케이션이 서로 다른 도메인에서 리소스를 공유할 수 있도록 하는 정책입니다.

1. HTTP/HTTPS
HTTP (Hypertext Transfer Protocol):
웹에서 데이터를 주고받는 기본적인 프로토콜입니다. 
클라이언트(웹 브라우저)가 서버에 요청을 보내고, 서버가 응답을 보내는 방식으로 동작합니다. 
암호화가 되지 않아 데이터가 노출될 위험이 있습니다.
HTTPS (Hypertext Transfer Protocol Secure):
HTTP와 동일하지만, SSL/TLS 암호화 기술을 사용하여 데이터를 안전하게 전송합니다. 데이터가 암호화되어 노출 위험을 줄일 수 있습니다.
2. RESTful API
REST (Representational State Transfer):
웹 서비스를 위한 디자인 스타일입니다. 
서버와 클라이언트 간의 상태 전송 없이, 클라이언트가 원하는 리소스(데이터)에 대한 요청을 보내고 서버가 응답하는 방식으로 동작합니다.
RESTful API:
REST 디자인 스타일을 따르는 API입니다. 리소스를 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 관리하고, 상태 전송을 최소화하여 효율적인 웹 서비스를 제공합니다.
3. WebSocket
WebSocket:
클라이언트와 서버 간의 실시간 양방향 통신을 위한 기술입니다. HTTP 기반이 아닌 TCP 연결을 사용하여 데이터 교환을 합니다.
특징:
실시간 통신: 웹 서버와 클라이언트 간에 지속적인 연결을 유지하여 실시간 데이터 교환이 가능합니다.
양방향 통신: 클라이언트와 서버 모두 데이터 송수신이 가능합니다.
HTTP보다 낮은 오버헤드: HTTP와 달리 매번 헤더를 전송하지 않아 네트워크 오버헤드가 적습니다.
4. CORS (Cross-Origin Resource Sharing)
CORS:
한 웹 애플리케이션이 다른 도메인(출처)에서 실행 중인 리소스에 접근할 수 있도록 허용하는 정책입니다.
원인:
웹 브라우저는 보안상의 이유로, 동일 출처 정책(SOP - Same Origin Policy)을 적용하여 다른 출처에서 실행되는 웹 애플리케이션이 자신의 리소스에 접근하는 것을 제한합니다.
해결:
CORS 설정은 브라우저가 다른 도메인에서 실행되는 웹 애플리케이션이 리소스에 접근할 수 있도록 허용하기 위해, 
서버에서 특정 헤더(Access-Control-Allow-Origin 등)를 설정하여 브라우저에게 알려주는 방식으로 동작합니다. 자세한 내용은 토스페이먼츠 개발자센터에서 확인할 수 있습니다.
CORS 에러:
브라우저가 CORS 정책에 위반되는 리소스 요청을 수행할 경우, CORS 에러가 발생합니다. 
예를 들어, 클라이언트 애플리케이션이 다른 도메인의 서버로부터 데이터를 요청하는 경우, 브라우저는 CORS 정책에 의해 접근이 제한될 수 있습니다. 
CORS 에러 해결 방법은 기억은 기록을 이기지 못한다 ??에서 확인할 수 있습니다.

< 멀티쓰레딩, 가상 메모리, 프로세스 & 스레드 차이>
멀티쓰레딩은 하나의 프로세스 내에서 여러 작업을 동시에 처리하는 방식이며, 
가상 메모리는 프로그램이 물리 메모리보다 큰 메모리 공간을 사용하는 기술입니다. 
프로세스와 스레드는 서로 다른 단위의 작업 수행이며, 프로세스는 독립적인 메모리 공간을 가지는 반면 스레드는 프로세스 내에서 공유 메모리 공간을 사용하는 작업 단위입니다. 

1. 멀티쓰레딩:
개념:
하나의 프로세스 내에서 여러 개의 스레드를 생성하여 작업을 동시에 처리하는 방식입니다. 
장점:
프로세스 간 통신 비용 감소: 스레드는 같은 메모리 공간을 공유하므로 프로세스 간 통신에 비해 효율적입니다. 
응답성 향상: 한 스레드가 블로킹될 경우 다른 스레드가 계속 작업을 진행할 수 있습니다. 
예:
서버 프로그램에서 여러 클라이언트의 요청을 동시에 처리하는 경우. 
2. 가상 메모리:
개념:
프로그램이 물리적 메모리보다 큰 메모리 공간을 사용할 수 있도록 해주는 기술입니다.
장점:
메모리 효율성 향상: 프로그램이 필요한 메모리 공간만 할당하고, 나머지 공간은 하드디스크와 같은 저장 장치에 저장하여 효율적으로 메모리를 사용할 수 있습니다.
프로그램 규모 확대: 물리적 메모리 제한 없이 큰 프로그램을 실행할 수 있습니다.
예:
웹 브라우저에서 많은 탭을 열거나, 대용량 파일을 처리하는 경우. 
3. 프로세스 vs 스레드:
구분 : 프로세스 / 스레드
개념 : 독립적인 작업 단위, 각 프로세스는 자신만의 메모리 공간을 가짐 / 프로세스 내에서 실행되는 작업 단위, 같은 메모리 공간을 공유
메모리 공간 :독립적 / 공유
스케줄링 : 가중치, 우선순위 등 복잡한 요소 고려 / 스케줄링 비용이 적어 더 가벼운 작업 처리 가능
상호작용 : 프로세스 간 통신 (IPC) 필요 / 스레드 간 공유 메모리 접근 가능
장점 : 안정성, 독립성, 보안 / 응답성, 성능, 메모리 효율성
단점 : 스케줄링 비용, 통신 비용 / 복잡한 동기화 문제, 코드 구조 어려움
예 : 웹 브라우저, 워드 프로세서, 게임 등 / 서버 프로그램, 멀티미디어 처리, 네트워크 통신 등

스레드(Thread)
운영체제에서 스레드는 프로세스 내부에서 실행되는 작은 작업 단위이다. 
스레드는 프로세스의 실행 흐름을 구성하는 단위로, 하나의 프로세스는 내부에 여러개의 스레드가 포함될 수 있다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<TCP/FTP>
TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 데이터 전송을 위한 두 가지 기본적인 프로토콜입니다. 
TCP는 신뢰성 높은 데이터 전송을 제공하는 반면, UDP는 빠르고 가벼운 전송을 목적으로 하지만 신뢰성은 다소 떨어집니다. 
각각의 사용 사례와 장단점을 이해하는 것은 네트워크 통신의 기본을 파악하는 데 필수적입니다.

FTP(File Transfer Protocol), 즉 파일 전송 프로토콜은 컴퓨터 네트워크를 통해 파일을 전송하기 위해 설계된 표준 네트워크 프로토콜입니다.
 웹 서버에 파일을 업로드하거나 서버에서 파일을 다운로드하는 데 널리 사용됩니다. 
FTP는 클라이언트-서버 모델을 기반으로 하며, 사용자 인증(아이디와 비밀번호)을 통해 보안을 제공합니다.

Socket이란?
네트워크를 경유하는 프로세스 간 통신의 종착점. OSI 7계층 중 응용 계층에 속하는 프로세스들은 데이터 송수신을 위해 반드시 소켓을 거쳐 전송 계층으로 데이터를 전달해야한다. 
즉, 소켓은 전송 계층과 응용 프로그램 사이의 인터페이스 역할을 하며 떨어져 있는 두 호스트를 연결해준다.

소켓은 아래의 3 요소로 정의된다.
프로토콜
IP
Port

-서버

소켓 생성
바인딩 (ip, port번호 설정)
listen()으로 클라이언트 요청에 대기열을 만들어 몇개의 클라이언트를 대기시킬지 결정
accept()로 클라이언트와 연결
데이터 송수신
소켓 닫기

-클라이언트

소켓 생성
서버에 설정된 ip, port로 연결 시도
accept()로 클라이언트의 socket descriptor 반환
데이터 송수신
소켓 닫기


소켓 종류
(1) 스트림 소켓
TCP(Transmission Control Protocol)을 사용하는 연결 지향방식의 소켓
송수신자의 연결을 보장하여 신뢰성있는 데이터 송수신이 가능
데이터의 순서 보장
소량의 데이터보다 대량 데이터 전송에 적합
점대점 연결


-서버
소켓 생성
바인딩
listen (연결되지 않은 소켓을 대기모드로 전환)
클라이언트 요청 수락 후 통신을 위한 실질적인 소켓 생성 (처음에 생성한 소켓은 새로운 클라이언트 요청을 대기하기 위해 쓰임)
데이터 송수신
소켓 닫음

-클라이언트
소켓 생성
서버가 설정한 ip, port로 연결
accept()로 클라이언트의 socket descriptor 반환
데이터 송수신
소켓 닫음

=> 시작전문-응답전문-데이타전송-완료전문-응답전문

(2) 데이터그램 소켓
UDP(User Diagram Protocol)을 사용하는 비연결형 소켓
데이터의 순서와 신뢰성을 보장하기 어려움
점대점 뿐만아니라 일대다 연결도 가능

accept 과정없이 소켓 생성 후 바로 데이터 송수신


HTTP 통신과 소켓 통신의 차이
(1) HTTP 통신
클라이언트의 요청이 있을 때만 서버가 응답
JSON, HTML, Image 등 다양한 데이터를 주고 받을 수 있음
서버가 응답한 후 연결을 바로 종료하는 단방향 통신이지만 Keep Alive 옵션을 주어 일정 시간동안 커넥션을 유지할 수 있다.
실시간 연결이 아닌 데이터 전달이 필요한 경우에만 요청을 보내는 상황에 유리

(2) 소켓 통신
클라이언트와 서버가 특정 포트를 통해 양방향 통신을 하는 방식
데이터 전달 후 연결이 끊어지는 것이 아니라 계속해서 연결을 유지 → HTTP에 비해 더 많은 리소스 소모
클라이언트와 서버가 실시간으로 계속하여 데이터를 주고받아야하는 경우에 유리
실시간 동영상 스트리밍이나 온라인 게임 등에 사용

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
REST API(레스트 API)란?

REST API란? 기본 개념과 활용 사례
REST API는 REST 아키텍처 스타일의 설계 원칙을 따르는  애플리케이션 프로그래밍 인터페이스(Application Programming Interface, API)입니다. 
REST는 Representational State Transfer의 줄임말로, 웹 API를 구축하는 방법에 대한 일련의 규칙 및 지침입니다.

API란? API의 정의와 유형
API 란 애플리케이션 소프트웨어를 구축하고 통합하는 데 대한 일련의 정의와 프로토콜입니다. 
이는 때때로 정보 사용자와  정보 제공자 간의 계약으로 지칭되며 소비자에게 필요한 콘텐츠(호출)와 생산자에게 필요한 콘텐츠(응답)를 구성합니다. 
예를 들어, 날씨 서비스용 API 설계 에서는 사용자는 우편번호 를 제공하고, 생산자는 두 부분(첫 번째는 최고 기온, 두 번째는 최저 기온)으로 구성된 응답으로 답하도록 지정할 수 있습니다.  

다시 말하면 정보를 검색하거나 기능을 수행하기 위해 컴퓨터 또는 시스템과 상호작용하려는 경우 API를 통해 원하는 작업이 무엇인지 시스템에 전달하여 시스템이 해당 요청을 이해한 다음 이행하도록 할 수 있습니다. 

API를 사용자 또는 클라이언트, 그리고 사용자와 클라이언트가 얻으려 하는 리소스 또는 웹 서비스 사이의 조정자로 생각하면 됩니다. 
API는 조직이 보안, 제어, 인증을 유지 관리(누가 무엇에 액세스할 수 있는지 결정)하면서 리소스와 정보를 공유할 수 있는 방법이기도 합니다. 

API의 또 다른 장점은 캐싱, 즉 리소스 검색 방법 또는 리소스의 출처에 대해 자세히 알 필요가 없다는 것입니다.

REST란? REST 아키텍처의 개념과 장점
REST는 프로토콜이나 표준이 아닌 아키텍처 제약 조건입니다. 
API 개발자는 다양한 방식으로 REST를 구현할 수 있습니다.

RESTful API를 통해 클라이언트 요청이 수행될 때 RESTful API는 리소스 상태에 대한 표현을 요청자 또는 엔드포인트에 전송합니다. 
이 정보 또는 표현은 HTTP: JSON(Javascript Object Notation), HTML, XLT, Python, PHP 또는 일반 텍스트를 통해 몇 가지 형식으로 전송됩니다. 
JSON은 그 이름에도 불구하고 사용 언어와 상관이 없을 뿐 아니라 인간과 머신이 모두 읽을 수 있기 때문에 가장 널리 사용되는 파일 형식입니다. 

그 외에 헤더 와 매개 변수는 요청의 메타데이터, 권한 부여, URI(Uniform Resource Identifier), 캐싱, 쿠키 등에 대한 중요한 식별자 정보를 포함하고 있기 때문에 
RESTful API HTTP 요청의 HTTP 메서드 에서도 중요하다는 점을 유의해야 합니다. 요청 헤더 와 응답 헤더가 있으며, 각각 고유한 HTTP 연결 정보 및 상태 코드가 있습니다.

API가 RESTful로 고려되려면 다음 기준을 충족해야 합니다.

클라이언트-서버 아키텍처: 클라이언트, 서버, 리소스로 구성되어 있고 요청이 HTTP를 통해 관리됨
스테이트리스(stateless) 클라이언트-서버 커뮤니케이션: GET 요청 간에 클라이언트 정보가 저장되지 않으며, 각 요청이 분리되어 있고 서로 연결되어 있지 않음
캐시 가능한 데이터: 클라이언트-서버 간 상호작용을 간소화함
구성 요소 간의 일관된 인터페이스: 정보가 표준 형식으로 전송되도록 함 이를 위한 요구 사항은 다음과 같습니다.
요청된 리소스가 식별 가능해야 하고 클라이언트에 전송된 표현과 구분되어야 합니다.
클라이언트가 수신하는 표현을 통해 리소스를 조작할 수 있어야 합니다(표현에는 해당 작업을 수행하는 데 충분한 정보가 포함되어 있음).
클라이언트에 반환되는 자기 기술적(Self-descriptive) 메시지에 클라이언트가 정보를 어떻게 처리해야 할지 설명하는 정보가 충분히 포함되어 있어야 합니다.
하이퍼텍스트/하이퍼미디어를 사용할 수 있어야 합니다. 즉, 클라이언트가 리소스에 액세스한 후 하이퍼링크를 사용해 현재 수행 가능한 기타 모든 작업을 찾을 수 있어야 합니다.
요청된 정보의 검색과 관련된 각 서버 유형(보안, 로드 밸런싱 등을 담당하는 서버 유형)을 클라이언트 에 보이지 않는 계층 구조로 구성하는 계층화된 시스템.
코드 온디맨드(선택 사항): 요청을 받으면 서버에서 클라이언트로 실행 가능한 코드를 전송하여 클라이언트 기능을 확장할 수 있는 기능. 
REST API는 이러한 기준을 준수해야 하지만, 여전히 SOAP(단순 객체 액세스 프로토콜, Simple Object Access Protocol)와 같이 규정된 프로토콜보다는 사용하기가 더 간단한 것으로 간주됩니다. 
SOAP의 경우 XML 메시징, 내장된 보안 기능, 트랜잭션 컴플라이언스와 같은 특정 요구 사항으로 인해 속도가 더디고 더 무겁습니다. 

이와 대조적으로 REST는 필요에 따라 구현 할 수 있는 일련의 지침으로, 이를 통해 REST API는 더 빨라지고 경량화되며 확장성이 증대되어 사물인터넷(IoT) 및 
모바일 애플리케이션 개발에 가장 적합한 API가 됩니다.
 
=====================================================================================================================================================================

웹스퀘어 (WebSquare)
인스웨이브사의 웹스퀘어는 웹표준을 따르는 UI/UX 개발툴이다. 함께 언급되는 툴로는 투비소프트의 Nexacro, xPlatform과 토마토시스템의 eXbuilder등이 있다.

웹 표준을 준수한 UI프레임워크로 UI컴포넌트와 Util API, 통합 개발 도구 제공하는 솔루션이라고 한다. 쉽게 말해 프론트 화면 개발 툴이다. 
디자인 탭에서 화면을 미리 볼 수 있는데 PPT에서 개체 추가 해주듯이 만들고자 하는 요소들을 추가하고, 속성에서 ID 지정 등 데이터를 입력한 뒤, 
Source 탭에 들어가보면 방금 마우스로 옮겨놓은 작업들이 HTML/JavaScript 소스로 완성되어 있다. 

구성 및 설정

웹 표준 준수로 설치과정에 별도의 Installer 및 Active-x등이 존재하지 않는다.
별도 설치과정 없이 Web Resource와 함께 포함되어 구성되며, 이때 WebSquare를 구동하기 위한 Servlet, 즉 웹 스퀘어 엔진을 등록하고 서버 설정 디렉토리를 지정해주면 된다.

화면 호출 방식

웹스퀘어로 개발 된 화면파일은 단독으로 브라우저에서 실행할 수 없다.
화면 파일은 웹스퀘어 JavaScript 엔진을 통해 실시간 해석되어 브라우저에 표시된다.
웹스퀘어 엔진은 서버에 배포된 websquare.html 파일을 통해 호출되고 엔진 로딩이 끝나면 실행된다. 즉, 모든 웹스퀘어 화면 파일은 websquare.html을 통해 실행된다.
일반적으로 화면 파일의 정보는 Get 방식의 파라미터를 통해 웹스퀘어 엔진에 전달된다.

https://domain.com/websquare/websquare.html?w2xPath=/MA/MA01M01.xml
https://qa-ontrust.cjhs.co.kr/websquare/websquare.html

http://domain.com : 서버 도메인
/websquare/websquare.html : 웹스퀘어 엔진 로딩 및 실행파일
HTML의 DocType, Meta등 정의
파일명 변경 가능하여 용도에 따라 파일 여러개 사용 가능
파일 확장자를 jsp로 변경할 수 있다.
?w2xPath=/MA/MA01M01.xml :웹 스퀘어 화면 파일 경로.
웹 스퀘어 엔진이 xml(UI grid)파일을 해석하여 HTML과 JavaScript를 생성하고 실행.

=====================================================================================================================================================================
API 문서화 도구인 Swagger

Swagger란?
Swagger 는 REST API를 설계, 빌드, 문서화 및 사용하는 데 도움이되는 OpenAPI 사양을 중심으로 구축 된 오픈 소스 도구 세트입니다. - About Swagger Specification

왜 사용할까?
Swagger를 사용하는 이유는 다음과 같다.

적용하기 쉽다.. Spring REST Docs라는 문서화 도구와는 달리 Swagger는 코드 몇 줄만 추가하면 만들 수 있다!
테스트 할 수 있는 UI를 제공한다. Spring REST Docs는 테스트를 돌리면서 성공하는지 실패하는지 확인하지만 Swagger는 문서 화면에서 API를 바로 테스트 할 수 있다.

=====================================================================================================================================================================

메시지 브로커(카프카)를 걷어내고 오라클 OGG로 대체 :db2db

카프카 : 비동기 메시지 큐

=====================================================================================================================================================================
